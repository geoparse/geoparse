

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>geospatial package &mdash; geospatial 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=7ab3649f" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=938c9ccc"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            geospatial
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">geospatial package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#geospatial-gindex-module">geospatial.gindex module</a></li>
<li><a class="reference internal" href="#module-geospatial.gutils">geospatial.gutils module</a><ul>
<li><a class="reference internal" href="#geospatial.gutils.find_proj"><code class="docutils literal notranslate"><span class="pre">find_proj()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.flatten_3d"><code class="docutils literal notranslate"><span class="pre">flatten_3d()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.geocoding_google"><code class="docutils literal notranslate"><span class="pre">geocoding_google()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.geom_stats"><code class="docutils literal notranslate"><span class="pre">geom_stats()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.haversine"><code class="docutils literal notranslate"><span class="pre">haversine()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.intersection"><code class="docutils literal notranslate"><span class="pre">intersection()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.line_to_points"><code class="docutils literal notranslate"><span class="pre">line_to_points()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.poverlay"><code class="docutils literal notranslate"><span class="pre">poverlay()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.quick_intersection"><code class="docutils literal notranslate"><span class="pre">quick_intersection()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.reverse_geocoding_google"><code class="docutils literal notranslate"><span class="pre">reverse_geocoding_google()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.trans_proj"><code class="docutils literal notranslate"><span class="pre">trans_proj()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.gutils.vincenty"><code class="docutils literal notranslate"><span class="pre">vincenty()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#geospatial-karta-module">geospatial.karta module</a></li>
<li><a class="reference internal" href="#module-geospatial.osm">geospatial.osm module</a><ul>
<li><a class="reference internal" href="#geospatial.osm.decode"><code class="docutils literal notranslate"><span class="pre">decode()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.osm.map_matching"><code class="docutils literal notranslate"><span class="pre">map_matching()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.osm.way_to_geom"><code class="docutils literal notranslate"><span class="pre">way_to_geom()</span></code></a></li>
<li><a class="reference internal" href="#geospatial.osm.ways_to_geom"><code class="docutils literal notranslate"><span class="pre">ways_to_geom()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#geospatial-pprocessing-module">geospatial.pprocessing module</a></li>
<li><a class="reference internal" href="#module-geospatial">Module contents</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">geospatial</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">geospatial package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/geospatial.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="geospatial-package">
<h1>geospatial package<a class="headerlink" href="#geospatial-package" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="geospatial-gindex-module">
<h2>geospatial.gindex module<a class="headerlink" href="#geospatial-gindex-module" title="Link to this heading"></a></h2>
</section>
<section id="module-geospatial.gutils">
<span id="geospatial-gutils-module"></span><h2>geospatial.gutils module<a class="headerlink" href="#module-geospatial.gutils" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.find_proj">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">find_proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geom</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Point</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Polygon</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">MultiPolygon</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#find_proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.find_proj" title="Link to this definition"></a></dt>
<dd><p>Determines the appropriate UTM zone projection for a given geometry.</p>
<p>Calculates the Universal Transverse Mercator (UTM) zone projection based on the centroid
coordinates of the input geometry. The function returns the corresponding EPSG code for
the UTM zone in which the geometry is located.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>geom</strong> (<em>Point</em><em>, </em><em>Polygon</em><em>, or </em><em>MultiPolygon</em>) – A Shapely geometry object, which can be a Point, Polygon, or MultiPolygon.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The EPSG code representing the UTM projection for the geometry’s location. For the
northern hemisphere, the function returns codes in the format ‘EPSG:326XX’. For the
southern hemisphere, it returns ‘EPSG:327XX’, where ‘XX’ is the UTM zone number.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The UTM (Universal Transverse Mercator) system divides the Earth into 60 longitudinal zones,
each 6 degrees wide. This function uses the centroid of the input geometry to determine the
appropriate zone and EPSG code.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">121</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">121</span><span class="p">,</span> <span class="mi">36</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">36</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">35</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_proj</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
<span class="go">&#39;EPSG:32610&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.flatten_3d">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">flatten_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geom</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GeoSeries</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Polygon</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">MultiPolygon</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#flatten_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.flatten_3d" title="Link to this definition"></a></dt>
<dd><p>Flattens a GeoSeries of 3D Polygons or MultiPolygons into 2D geometries.</p>
<p>This function removes the z-coordinate from each 3D geometry in the input GeoSeries,
converting it into a 2D Polygon or MultiPolygon. The result is a list of 2D geometries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>geom</strong> (<em>gpd.GeoSeries</em>) – A GeoSeries containing 3D Polygons or MultiPolygons (geometries with z-coordinates).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of 2D Polygons or MultiPolygons with the z-coordinates removed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[Union[Polygon, MultiPolygon]]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">flatten_3d</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
<span class="go">    Converts all 3D geometries in the GeoSeries `gdf.geometry` to 2D geometries.</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The function is useful when working with datasets that contain 3D geometries but
only 2D geometries are needed for further spatial analysis or visualization.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.geocoding_google">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">geocoding_google</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address_or_zipcode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">api_key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Series</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#geocoding_google"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.geocoding_google" title="Link to this definition"></a></dt>
<dd><p>Returns geographic coordinates (latitude and longitude) for a given address or zip code using the Google Geocoding API.</p>
<p>This function utilizes the Google Geocoding API to convert a given address or zip code into geographic coordinates.
The function returns the latitude and longitude as a pandas Series. If the request is unsuccessful or the address
is not found, the function returns a Series with <cite>(None, None)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address_or_zipcode</strong> (<em>str</em>) – A text-based address or zip code that needs to be geocoded.</p></li>
<li><p><strong>api_key</strong> (<em>str</em>) – A valid Google Maps API key required to access the Google Geocoding service.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pandas Series containing the latitude and longitude as floats. If the request fails or the address is not found,
returns a Series with <cite>(None, None)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.Series</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">geocoding_google</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="s2">&quot;your_api_key&quot;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">geocoding_google</span><span class="p">(</span><span class="s2">&quot;1600 Amphitheatre Parkway, Mountain View, CA&quot;</span><span class="p">,</span> <span class="s2">&quot;your_api_key&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">lat    37.4224764</span>
<span class="go">lon   -122.0842499</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Make sure to enable the Google Geocoding API in your Google Cloud Console and provide a valid API key.</p></li>
<li><p>The API might return ambiguous results if the input address is incomplete or vague.</p></li>
<li><p>Consider handling <cite>None</cite> values in the returned Series if the API fails to find the address or the request limit is exceeded.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If there is an error in the API request or response parsing, an exception is raised with an error message.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.geom_stats">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">geom_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geom</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Polygon</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">MultiPolygon</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'m'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#geom_stats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.geom_stats" title="Link to this definition"></a></dt>
<dd><p>Computes geometric statistics for a Polygon or MultiPolygon geometry.</p>
<p>Calculates various statistics for a given Shapely geometry, such as the number of shells (outer boundaries),
number of holes, number of shell points, total area, and total border length. If no geometry is provided,
the function will print a usage example.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geom</strong> (<em>Polygon</em><em> or </em><em>MultiPolygon</em><em>, </em><em>optional</em>) – A Shapely geometry object (Polygon or MultiPolygon) for which to compute the statistics. If not provided,
the function will print a usage example and not perform any computations. Default is None.</p></li>
<li><p><strong>unit</strong> (<em>str</em><em>, </em><em>optional</em>) – The unit for area and length calculations. Accepts “m” for meters and “km” for kilometers. Default is “m”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A list containing the following statistics in order:</dt><dd><ul class="simple">
<li><p>Number of shells (int)</p></li>
<li><p>Number of holes (int)</p></li>
<li><p>Number of shell points (int)</p></li>
<li><p>Total area (float, rounded to nearest integer in the specified unit)</p></li>
<li><p>Total border length (float, rounded to nearest integer in the specified unit)</p></li>
</ul>
</dd>
</dl>
<p>If no geometry is provided, the function returns None.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of int or float, optional</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compute_geometry_statistics</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;km&quot;</span><span class="p">)</span>
<span class="go">[1, 0, 5, 1.0, 4.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.haversine">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">haversine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#haversine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.haversine" title="Link to this definition"></a></dt>
<dd><p>Calculates the great-circle distance between two points on the Earth’s surface.</p>
<p>The haversine formula determines the shortest distance over the Earth’s surface
between two points given their latitudes and longitudes. The result is the
distance in meters, based on a mean Earth radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat1</strong> (<em>float</em>) – Latitude of the first point in decimal degrees.</p></li>
<li><p><strong>lon1</strong> (<em>float</em>) – Longitude of the first point in decimal degrees.</p></li>
<li><p><strong>lat2</strong> (<em>float</em>) – Latitude of the second point in decimal degrees.</p></li>
<li><p><strong>lon2</strong> (<em>float</em>) – Longitude of the second point in decimal degrees.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The great-circle distance between the two points in meters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Haversine_formula">https://en.wikipedia.org/wiki/Haversine_formula</a></p>
</aside>
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Longitude">https://en.wikipedia.org/wiki/Longitude</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">haversine</span><span class="p">(</span><span class="mf">52.2296756</span><span class="p">,</span> <span class="mf">21.0122287</span><span class="p">,</span> <span class="mf">41.8919300</span><span class="p">,</span> <span class="mf">12.5113300</span><span class="p">)</span>
<span class="go">1319743.483</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The mean Earth radius is taken as 6,371,008.8 meters.
a = 6378137.0        # Equatorial radius
b = 6356752.3142     # Polar radius
R = (2*a + b)/3      # Mean radius = 6371008.7714</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.intersection">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GeoDataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GeoDataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeoDataFrame</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#intersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.intersection" title="Link to this definition"></a></dt>
<dd><p>Performs a spatial intersection between two GeoDataFrames and return the intersecting subset of the first GeoDataFrame.</p>
<p>This function identifies geometries in <cite>gdf1</cite> that intersect with any geometries in <cite>gdf2</cite>. It adds a new column, <cite>counts</cite>,
to <cite>gdf2</cite> representing the number of intersecting geometries for each feature in <cite>gdf2</cite>. If a <cite>poly_id</cite> column is specified,
it also adds the geometry ID from <cite>gdf2</cite> to the intersected subset of <cite>gdf1</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf1</strong> (<em>geopandas.GeoDataFrame</em>) – The first GeoDataFrame whose geometries are tested for intersection with <cite>gdf2</cite>.</p></li>
<li><p><strong>gdf2</strong> (<em>geopandas.GeoDataFrame</em>) – The second GeoDataFrame containing geometries to intersect with <cite>gdf1</cite>.</p></li>
<li><p><strong>poly_id</strong> (<em>str</em><em>, </em><em>optional</em>) – The column name in <cite>gdf2</cite> containing unique geometry identifiers. If provided, the intersected subset of <cite>gdf1</cite>
will include a new column <cite>geom_id</cite> indicating the geometry ID from <cite>gdf2</cite> that each feature intersects with.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new GeoDataFrame containing only the intersecting geometries from <cite>gdf1</cite> with respect to <cite>gdf2</cite>.
If <cite>poly_id</cite> is provided, the intersected GeoDataFrame will also include a <cite>geom_id</cite> column.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>geopandas.GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf1</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data1.shp&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf2</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data2.shp&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result_gdf</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">poly_id</span><span class="o">=</span><span class="s2">&quot;region_id&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The function modifies <cite>gdf2</cite> in place by adding a <cite>counts</cite> column, which reflects the number of geometries
in <cite>gdf1</cite> that intersect with each geometry in <cite>gdf2</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.line_to_points">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">line_to_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GeoSeries</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeoDataFrame</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#line_to_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.line_to_points" title="Link to this definition"></a></dt>
<dd><p>Splits a LineString geometry into individual Point geometries while preserving original attributes.</p>
<p>This function takes a GeoSeries representing a single row of a GeoDataFrame, extracts the coordinates
from a LineString geometry, and creates a new GeoDataFrame with each Point as a separate row. All original
attributes from the input row are preserved in the new GeoDataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>row</strong> (<em>gpd.GeoSeries</em>) – A GeoSeries representing a single row of a GeoDataFrame. It must include a ‘geometry’ column
containing a LineString geometry.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new GeoDataFrame where each row corresponds to a Point geometry derived from the coordinates of the LineString.
All other columns from the original row are preserved.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">line_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point_gdf</span> <span class="o">=</span> <span class="n">line_to_points</span><span class="p">(</span><span class="n">line_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point_gdf</span><span class="p">)</span>
<span class="go">   geometry</span>
<span class="go">0  POINT (0 0)</span>
<span class="go">1  POINT (1 1)</span>
<span class="go">2  POINT (2 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.poverlay">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">poverlay</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GeoDataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GeoDataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'intersection'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_geom_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeoDataFrame</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#poverlay"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.poverlay" title="Link to this definition"></a></dt>
<dd><p>Performs a spatial overlay operation between two GeoDataFrames in parallel using multiple CPU cores.</p>
<p>This function divides the first GeoDataFrame into chunks according to the number of available CPU cores
and applies the specified overlay operation (e.g., intersection, union, difference) in parallel on each chunk
with respect to the second GeoDataFrame. The results are then concatenated and returned as a single GeoDataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf1</strong> (<em>gpd.GeoDataFrame</em>) – The first GeoDataFrame to be used in the spatial overlay operation.</p></li>
<li><p><strong>gdf2</strong> (<em>gpd.GeoDataFrame</em>) – The second GeoDataFrame to be used in the spatial overlay operation.</p></li>
<li><p><strong>how</strong> (<em>str</em><em>, </em><em>optional</em>) – The type of overlay operation to perform. Options include “intersection”, “union”, “difference”,
“symmetric_difference”, and “identity”. Defaults to “intersection”.</p></li>
<li><p><strong>keep_geom_type</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to retain the original geometry type (e.g., Polygon, LineString) in the resulting overlay.
If set to True, only features of the same geometry type are retained. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new GeoDataFrame resulting from the spatial overlay operation, with the same coordinate reference system
(CRS) as the first input GeoDataFrame (<cite>gdf1</cite>).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf1</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf2</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result_gdf</span> <span class="o">=</span> <span class="n">poverlay</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result_gdf</span><span class="p">)</span>
<span class="go">                                             geometry</span>
<span class="go">0  POLYGON ((2.00000 1.00000, 2.00000 2.00000, 1....</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The spatial overlay operation is performed using the <cite>geopandas.overlay</cite> function. The parallelization is achieved
using the <cite>multiprocessing</cite> library to divide and distribute the overlay operations across multiple CPU cores.</p></li>
<li><p>Ensure that both GeoDataFrames (<cite>gdf1</cite> and <cite>gdf2</cite>) have the same coordinate reference system (CRS) before applying
the overlay operation to avoid unexpected results.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the <cite>how</cite> parameter is not one of the supported overlay operation types: “intersection”, “union”,
    “difference”, “symmetric_difference”, or “identity”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.quick_intersection">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">quick_intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GeoDataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GeoDataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeoDataFrame</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#quick_intersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.quick_intersection" title="Link to this definition"></a></dt>
<dd><p>Performs a quick spatial intersection between two GeoDataFrames using bounding box optimization.</p>
<p>This function identifies geometries in <cite>gdf1</cite> that intersect with any geometries in <cite>gdf2</cite>. It uses
a spatial index to quickly filter <cite>gdf1</cite> geometries that are likely to intersect with the bounding
box of each geometry in <cite>gdf2</cite>. It then performs a precise intersection check on this subset, improving
the performance of the intersection operation.</p>
<p>If a <cite>poly_id</cite> column is provided, the function adds a new <cite>geom_id</cite> column to the resulting intersected
GeoDataFrame, storing the geometry ID from <cite>gdf2</cite> that each feature in <cite>gdf1</cite> intersects with. It also
modifies <cite>gdf2</cite> by adding a <cite>counts</cite> column to indicate the number of intersecting geometries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf1</strong> (<em>geopandas.GeoDataFrame</em>) – The first GeoDataFrame whose geometries are tested for intersection with <cite>gdf2</cite>.</p></li>
<li><p><strong>gdf2</strong> (<em>geopandas.GeoDataFrame</em>) – The second GeoDataFrame containing geometries to intersect with <cite>gdf1</cite>.</p></li>
<li><p><strong>poly_id</strong> (<em>str</em><em>, </em><em>optional</em>) – The column name in <cite>gdf2</cite> containing unique geometry identifiers. If provided, the intersected subset of <cite>gdf1</cite>
will include a new column <cite>geom_id</cite> indicating the geometry ID from <cite>gdf2</cite> that each feature intersects with.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new GeoDataFrame containing only the intersecting geometries from <cite>gdf1</cite> with respect to <cite>gdf2</cite>.
If <cite>poly_id</cite> is provided, the intersected GeoDataFrame will also include a <cite>geom_id</cite> column.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>geopandas.GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf1</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data1.shp&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf2</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data2.shp&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result_gdf</span> <span class="o">=</span> <span class="n">quick_intersection</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">poly_id</span><span class="o">=</span><span class="s2">&quot;region_id&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function modifies <cite>gdf2</cite> in place by adding a <cite>counts</cite> column, which reflects the number of geometries
in <cite>gdf1</cite> that intersect with each geometry in <cite>gdf2</cite>.</p></li>
<li><p>It leverages spatial indexing using the <cite>sindex</cite> attribute of <cite>gdf1</cite> to quickly identify candidates for
intersection, which significantly improves performance for large datasets.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.reverse_geocoding_google">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">reverse_geocoding_google</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">api_key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#reverse_geocoding_google"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.reverse_geocoding_google" title="Link to this definition"></a></dt>
<dd><p>Returns the postal code for a given geographic coordinate (latitude, longitude) using the Google Geocoding API.</p>
<p>This function makes a reverse geocoding request to the Google Geocoding API to obtain the postal code associated
with the provided latitude and longitude. If the postal code is found, it is returned as a string. If not,
<cite>None</cite> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat</strong> (<em>float</em>) – The latitude of the location to reverse geocode.</p></li>
<li><p><strong>lon</strong> (<em>float</em>) – The longitude of the location to reverse geocode.</p></li>
<li><p><strong>api_key</strong> (<em>str</em>) – A valid Google Maps API key for accessing the geocoding service.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The postal code corresponding to the input geographic coordinates, if found. Returns <cite>None</cite> if no postal code
is found or if the request fails.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reverse_geocoding_google</span><span class="p">(</span><span class="mf">37.4224764</span><span class="p">,</span> <span class="o">-</span><span class="mf">122.0842499</span><span class="p">,</span> <span class="s2">&quot;your_api_key&quot;</span><span class="p">)</span>
<span class="go">&#39;94043&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;postcode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">reverse_geocoding_google</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="s2">&quot;your_api_key&quot;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.trans_proj">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">trans_proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geom</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseGeometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseGeometry</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#trans_proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.trans_proj" title="Link to this definition"></a></dt>
<dd><p>Transforms a Shapely geometry object from one CRS to another.</p>
<p>Uses <cite>pyproj</cite> to create a transformation pipeline that converts the input geometry
from the source CRS (<cite>proj1</cite>) to the target CRS (<cite>proj2</cite>). The resulting geometry
is returned in the new coordinate reference system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geom</strong> (<em>BaseGeometry</em>) – A Shapely geometry object to be transformed. This can include Point, Polygon,
MultiPolygon, LineString, or any other Shapely geometry type.</p></li>
<li><p><strong>proj1</strong> (<em>str</em>) – The EPSG code or PROJ string representing the source CRS of the input geometry.</p></li>
<li><p><strong>proj2</strong> (<em>str</em>) – The EPSG code or PROJ string representing the target CRS for the transformed geometry.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed Shapely geometry object in the target projection.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>BaseGeometry</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function requires <cite>pyproj</cite> and <cite>shapely</cite> libraries.</p></li>
<li><p>Ensure that the input and output CRS definitions are valid and supported by <cite>pyproj</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans_proj</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="s2">&quot;EPSG:32632&quot;</span><span class="p">)</span>
<span class="go">&lt;Point object at 0x...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.gutils.vincenty">
<span class="sig-prename descclassname"><span class="pre">geospatial.gutils.</span></span><span class="sig-name descname"><span class="pre">vincenty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/geospatial/gutils.html#vincenty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.gutils.vincenty" title="Link to this definition"></a></dt>
<dd><p>Calculates the geodesic distance between two points on the Earth’s surface
using the Vincenty formula, which accounts for the Earth’s ellipsoidal shape.</p>
<p>Parameters:
- lat1, lon1: Latitude and longitude of the first point (in degrees).
- lat2, lon2: Latitude and longitude of the second point (in degrees).</p>
<p>Returns:
- Distance between the two points in meters.</p>
<p>Notes:
- This implementation may encounter numerical issues, such as divide-by-zero errors,</p>
<blockquote>
<div><p>in edge cases where the points are on opposite sides of the Earth or on the same meridian
e.g., from (0,0) to (0,90).However, for points (0,0) to (0.001,90), the distance calculation
is accurate within a small error margin (about 9.3e-06 meters).</p>
</div></blockquote>
<ul class="simple">
<li><p>The error in the above approach can be significant for very small distances,
such as between (0,0) and (0,0.001).</p></li>
</ul>
</dd></dl>

</section>
<section id="geospatial-karta-module">
<h2>geospatial.karta module<a class="headerlink" href="#geospatial-karta-module" title="Link to this heading"></a></h2>
</section>
<section id="module-geospatial.osm">
<span id="geospatial-osm-module"></span><h2>geospatial.osm module<a class="headerlink" href="#module-geospatial.osm" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="geospatial.osm.decode">
<span class="sig-prename descclassname"><span class="pre">geospatial.osm.</span></span><span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/geospatial/osm.html#decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.osm.decode" title="Link to this definition"></a></dt>
<dd><p>Decodes an encoded polyline string from Valhalla into a list of coordinates.</p>
<p>Valhalla routing, map-matching, and elevation services use an encoded polyline format
to store a series of latitude and longitude coordinates as a single string. This function
decodes the polyline into a list of coordinates with six decimal precision.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded</strong> (<em>str</em>) – An encoded polyline string as per the Valhalla encoding format.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of [longitude, latitude] pairs decoded from the input polyline string.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of list of float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses six decimal degrees of precision for decoding Valhalla’s encoded polylines.</p></li>
<li><p>The decoded coordinates are returned in [longitude, latitude] format.</p></li>
</ul>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/valhalla/valhalla-docs/blob/master/decoding.md#decode-a-route-shape">https://github.com/valhalla/valhalla-docs/blob/master/decoding.md#decode-a-route-shape</a></p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encoded_polyline</span> <span class="o">=</span> <span class="s2">&quot;_p~iF~ps|U_ulLnnqC_mqNvxq`@&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoded_coords</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">encoded_polyline</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">decoded_coords</span><span class="p">)</span>
<span class="go">[[-120.2, 38.5], [-120.95, 40.7], [-126.453, 43.252]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.osm.map_matching">
<span class="sig-prename descclassname"><span class="pre">geospatial.osm.</span></span><span class="sig-name descname"><span class="pre">map_matching</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">DataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cost</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">url</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'osrm'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="reference internal" href="_modules/geospatial/osm.html#map_matching"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.osm.map_matching" title="Link to this definition"></a></dt>
<dd><p>Performs map matching using Valhalla’s Meili service.</p>
<p>Map matching aligns a series of GPS points onto a road network. This function takes a DataFrame
of coordinates, sends a request to the Meili map-matching service, and returns the matched
coordinates along with other route information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pd.DataFrame</em>) – A pandas DataFrame containing the GPS coordinates to be map-matched. It should be in the
format of [{“lon”: float, “lat”: float}, …].</p></li>
<li><p><strong>cost</strong> (<em>str</em>) – The routing profile to use for map matching. Common values include “auto”, “bicycle”,
or “pedestrian”.</p></li>
<li><p><strong>url</strong> (<em>str</em>) – The URL endpoint for the Meili map-matching service.</p></li>
<li><p><strong>format</strong> (<em>str</em><em>, </em><em>optional</em>) – The response format for the request, either “osrm” or “geojson”. Defaults to “osrm”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary representing the JSON response from the map-matching service if the request
is successful, otherwise None.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Optional[dict]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coordinates</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">73.9857</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="mf">40.7484</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">73.9851</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="mf">40.7478</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://valhalla.mapzen.com/trace_attributes&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matched_route</span> <span class="o">=</span> <span class="n">map_matching</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">matched_route</span><span class="p">)</span>
<span class="go">{&#39;shape&#39;: &#39;_p~iF~ps|U_ulLnnqC_mqNvxq`@&#39;, &#39;confidence_score&#39;: 1.0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.osm.way_to_geom">
<span class="sig-prename descclassname"><span class="pre">geospatial.osm.</span></span><span class="sig-name descname"><span class="pre">way_to_geom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">way_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">url</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/geospatial/osm.html#way_to_geom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.osm.way_to_geom" title="Link to this definition"></a></dt>
<dd><p>Converts an OSM way ID into a Shapely Polygon or LineString object.</p>
<p>This function retrieves the geometry corresponding to the given OSM way ID and
returns it as a Shapely <cite>Polygon</cite> or <cite>LineString</cite> object based on whether the way
forms a closed loop or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>way_id</strong> (<em>int</em>) – The OpenStreetMap (OSM) way ID to be retrieved.</p></li>
<li><p><strong>url</strong> (<em>str</em>) – The URL endpoint for the Overpass API to request the geometry.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Shapely <cite>Polygon</cite> object if the way forms a closed loop, or a <cite>LineString</cite>
object otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>shapely.geometry.Polygon or shapely.geometry.LineString</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function constructs an Overpass API query using the given way ID,
requests the geometry, and then converts it into a Shapely geometry.</p></li>
<li><p>Assumes that the Overpass API returns data in JSON format with a “geometry” attribute.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">way_id</span> <span class="o">=</span> <span class="mi">123456</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://overpass-api.de/api/interpreter&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geometry</span> <span class="o">=</span> <span class="n">way_to_geom</span><span class="p">(</span><span class="n">way_id</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
<span class="go">POLYGON ((13.3888 52.5170, 13.3976 52.5291, 13.4286 52.5232, 13.3888 52.5170))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="geospatial.osm.ways_to_geom">
<span class="sig-prename descclassname"><span class="pre">geospatial.osm.</span></span><span class="sig-name descname"><span class="pre">ways_to_geom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">url</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/geospatial/osm.html#ways_to_geom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#geospatial.osm.ways_to_geom" title="Link to this definition"></a></dt>
<dd><p>Converts an array of OpenStreetMap (OSM) way IDs into Shapely geometries.</p>
<p>This function retrieves the geometries corresponding to the given OSM way IDs and
returns a list of Shapely <cite>LineString</cite> or <cite>Polygon</cite> objects based on the geometries
fetched from the OSM API.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ids</strong> (<em>list</em><em> of </em><em>int</em>) – A list of OSM way IDs to be retrieved.</p></li>
<li><p><strong>url</strong> (<em>str</em>) – The URL endpoint for the Overpass API to request the geometries.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of Shapely <cite>LineString</cite> or <cite>Polygon</cite> objects representing the geometries
of the OSM ways. If the way forms a closed loop, it is returned as a <cite>Polygon</cite>;
otherwise, it is returned as a <cite>LineString</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of shapely.geometry.LineString or shapely.geometry.Polygon</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function constructs an Overpass API query using the given IDs, requests the
geometries, and then converts them into Shapely geometries.</p></li>
<li><p>The function assumes that the Overpass API returns data in JSON format and expects
the “geometry” attribute to contain the coordinates.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">way_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">123456</span><span class="p">,</span> <span class="mi">234567</span><span class="p">,</span> <span class="mi">345678</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://overpass-api.de/api/interpreter&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geometries</span> <span class="o">=</span> <span class="n">ways_to_geom</span><span class="p">(</span><span class="n">way_ids</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">geometries</span><span class="p">)</span>
<span class="go">[&lt;shapely.geometry.polygon.Polygon object at 0x...&gt;,</span>
<span class="go"> &lt;shapely.geometry.linestring.LineString object at 0x...&gt;]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="geospatial-pprocessing-module">
<h2>geospatial.pprocessing module<a class="headerlink" href="#geospatial-pprocessing-module" title="Link to this heading"></a></h2>
</section>
<section id="module-geospatial">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-geospatial" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Abbas Kiasari.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>