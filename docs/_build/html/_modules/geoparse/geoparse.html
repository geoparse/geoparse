

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>geoparse.geoparse &mdash; GeoParse 0.4.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=c87aa342"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GeoParse
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GeoParse</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">geoparse.geoparse</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for geoparse.geoparse</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">atan2</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">radians</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">folium</span>  <span class="c1"># Folium is a Python library used for visualising geospatial data. Actually, it&#39;s a Python wrapper for Leaflet which is a leading open-source JavaScript library for plotting interactive maps.</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">h3</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygeohash</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyproj</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">branca.element</span><span class="w"> </span><span class="kn">import</span> <span class="n">MacroElement</span><span class="p">,</span> <span class="n">Template</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">folium</span><span class="w"> </span><span class="kn">import</span> <span class="n">plugins</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">polygon_geohasher.polygon_geohasher</span><span class="w"> </span><span class="kn">import</span> <span class="n">geohash_to_polygon</span><span class="p">,</span> <span class="n">polygon_to_geohashes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">s2</span><span class="w"> </span><span class="kn">import</span> <span class="n">s2</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseGeometry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.ops</span><span class="w"> </span><span class="kn">import</span> <span class="n">transform</span>


<div class="viewcode-block" id="Karta">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.Karta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Karta</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_base_map</span><span class="p">(</span><span class="n">sw</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">ne</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a base map with multiple tile layers and fits the map to the specified bounding box.</span>

<span class="sd">        This function initializes a Folium map object with multiple tile layers, including:</span>
<span class="sd">        - `Bright Mode` (CartoDB Positron)</span>
<span class="sd">        - `Dark Mode` (CartoDB Dark Matter)</span>
<span class="sd">        - `Satellite` (Esri World Imagery)</span>
<span class="sd">        - `OpenStreetMap` (OSM)</span>

<span class="sd">        It then fits the map&#39;s view to the bounding box defined by the southwest (`sw`) and northeast (`ne`) coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sw : list or tuple</span>
<span class="sd">            The southwest coordinate [latitude, longitude] of the bounding box to fit the map view.</span>

<span class="sd">        ne : list or tuple</span>
<span class="sd">            The northeast coordinate [latitude, longitude] of the bounding box to fit the map view.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        folium.Map</span>
<span class="sd">            A Folium map object with multiple tile layers and the view fitted to the provided bounding box.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sw = [51.2652, -0.5426]  # Southwest coordinate (London, UK)</span>
<span class="sd">        &gt;&gt;&gt; ne = [51.7225, 0.2824]  # Northeast coordinate (London, UK)</span>
<span class="sd">        &gt;&gt;&gt; karta = Karta._base_map(sw, ne)</span>
<span class="sd">        &gt;&gt;&gt; karta.save(&quot;map.html&quot;)  # Save the map to an HTML file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the base map without any default tiles</span>
        <span class="n">karta</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">tiles</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Dictionary of tile layers to be added</span>
        <span class="n">tiles</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;cartodbpositron&quot;</span><span class="p">:</span> <span class="s2">&quot;Light&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cartodbdark_matter&quot;</span><span class="p">:</span> <span class="s2">&quot;Dark&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Add each tile layer to the map</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">:</span>
            <span class="n">folium</span><span class="o">.</span><span class="n">TileLayer</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">tiles</span><span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="n">max_zoom</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

        <span class="c1"># Add OpenTopoMap as a tile layer</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">TileLayer</span><span class="p">(</span>
            <span class="n">tiles</span><span class="o">=</span><span class="s2">&quot;https://</span><span class="si">{s}</span><span class="s2">.tile.opentopomap.org/</span><span class="si">{z}</span><span class="s2">/</span><span class="si">{x}</span><span class="s2">/</span><span class="si">{y}</span><span class="s2">.png&quot;</span><span class="p">,</span>
            <span class="n">attr</span><span class="o">=</span><span class="s1">&#39;© &lt;a href=&quot;https://www.openstreetmap.org/copyright&quot;&gt;OpenStreetMap&lt;/a&gt; contributors © &lt;a href=&quot;https://opentopomap.org/&quot;&gt;OpenTopoMap&lt;/a&gt;&#39;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Outdoors&quot;</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

        <span class="c1"># Add a satellite tile layer (Esri World Imagery)</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">TileLayer</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Satellite&quot;</span><span class="p">,</span>
            <span class="n">attr</span><span class="o">=</span><span class="s1">&#39;© &lt;a href=&quot;https://www.esri.com/en-us/legal/overview&quot;&gt;Esri&lt;/a&gt;&#39;</span><span class="p">,</span>
            <span class="n">tiles</span><span class="o">=</span><span class="s2">&quot;https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/</span><span class="si">{z}</span><span class="s2">/</span><span class="si">{y}</span><span class="s2">/</span><span class="si">{x}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">overlay</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">control</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">max_zoom</span><span class="o">=</span><span class="mi">19</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

        <span class="c1"># Add OpenStreetMap (OSM) tile layer</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">TileLayer</span><span class="p">(</span><span class="s2">&quot;openstreetmap&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;OSM&quot;</span><span class="p">,</span> <span class="n">max_zoom</span><span class="o">=</span><span class="mi">19</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

        <span class="c1"># Fit the map&#39;s view to the bounding box defined by the southwest and northeast coordinates</span>
        <span class="n">karta</span><span class="o">.</span><span class="n">fit_bounds</span><span class="p">([</span><span class="n">sw</span><span class="p">,</span> <span class="n">ne</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">karta</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_select_color</span><span class="p">(</span><span class="n">col</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">head</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a consistent color based on the input column value by mapping it to a predefined color palette.</span>

<span class="sd">        This function uses a set color palette and maps the given column value to a color. If the column value is a string,</span>
<span class="sd">        a substring can be selected using `head` and `tail` indices, and it will be converted to a numerical index. If the</span>
<span class="sd">        column value is an integer, it will directly be mapped to a color using modulo arithmetic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        col : int, float or str</span>
<span class="sd">            The column value to be mapped to a color. It can be either a number or a string.</span>
<span class="sd">            - If a number, it is directly used for color mapping.</span>
<span class="sd">            - If a string, it will be cleaned of non-alphanumeric characters, and a substring defined by `head` and `tail`</span>
<span class="sd">              can be selected for mapping.</span>

<span class="sd">        head : int, optional</span>
<span class="sd">            The starting index of the substring to be used for color mapping if `col` is a string. Default is None.</span>

<span class="sd">        tail : int, optional</span>
<span class="sd">            The ending index of the substring to be used for color mapping if `col` is a string. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A hexadecimal color code selected from the predefined palette corresponding to the input column value.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Karta._select_color(&quot;Category1&quot;)</span>
<span class="sd">        &#39;#e6194b&#39;  # Red color from the palette</span>

<span class="sd">        &gt;&gt;&gt; Karta._select_color(5)</span>
<span class="sd">        &#39;#3cb44b&#39;  # Green color from the palette</span>

<span class="sd">        &gt;&gt;&gt; Karta._select_color(&quot;Example&quot;, head=0, tail=3)</span>
<span class="sd">        &#39;#e12348&#39;  # Bright Red from the palette</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Predefined color palette</span>
        <span class="n">palettet</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;#e6194b&quot;</span><span class="p">,</span>  <span class="c1"># red</span>
            <span class="s2">&quot;#4363d8&quot;</span><span class="p">,</span>  <span class="c1"># blue</span>
            <span class="s2">&quot;#3cb44b&quot;</span><span class="p">,</span>  <span class="c1"># green</span>
            <span class="s2">&quot;#800000&quot;</span><span class="p">,</span>  <span class="c1"># maroon (dark red)</span>
            <span class="s2">&quot;#008080&quot;</span><span class="p">,</span>  <span class="c1"># teal (dark green)</span>
            <span class="s2">&quot;#000080&quot;</span><span class="p">,</span>  <span class="c1"># navy (dark blue)</span>
            <span class="s2">&quot;#f58231&quot;</span><span class="p">,</span>  <span class="c1"># orange</span>
            <span class="s2">&quot;#911eb4&quot;</span><span class="p">,</span>  <span class="c1"># purple</span>
            <span class="s2">&quot;#808000&quot;</span><span class="p">,</span>  <span class="c1"># olive</span>
            <span class="s2">&quot;#9a6324&quot;</span><span class="p">,</span>  <span class="c1"># brown</span>
            <span class="s2">&quot;#f032e6&quot;</span><span class="p">,</span>  <span class="c1"># magenta</span>
            <span class="s2">&quot;#dfb119&quot;</span><span class="p">,</span>  <span class="c1"># dark yellow</span>
            <span class="s2">&quot;#42d4f4&quot;</span><span class="p">,</span>  <span class="c1"># cyan</span>
            <span class="s2">&quot;#808080&quot;</span><span class="p">,</span>  <span class="c1"># grey</span>
            <span class="s2">&quot;#e12348&quot;</span><span class="p">,</span>  <span class="c1"># Bright Red</span>
            <span class="s2">&quot;#dc2c46&quot;</span><span class="p">,</span>  <span class="c1"># Strong Red</span>
            <span class="s2">&quot;#d73644&quot;</span><span class="p">,</span>  <span class="c1"># Vivid Red</span>
            <span class="s2">&quot;#cd4a40&quot;</span><span class="p">,</span>  <span class="c1"># Deep Red</span>
            <span class="s2">&quot;#c8543e&quot;</span><span class="p">,</span>  <span class="c1"># Intense Red</span>
            <span class="s2">&quot;#c25e3c&quot;</span><span class="p">,</span>  <span class="c1"># Fire Red</span>
            <span class="s2">&quot;#bd683a&quot;</span><span class="p">,</span>  <span class="c1"># Scarlet</span>
            <span class="s2">&quot;#b77238&quot;</span><span class="p">,</span>  <span class="c1"># Fiery Orange</span>
            <span class="s2">&quot;#b27c36&quot;</span><span class="p">,</span>  <span class="c1"># Tangerine</span>
            <span class="s2">&quot;#ad8634&quot;</span><span class="p">,</span>  <span class="c1"># Burnt Orange</span>
        <span class="p">]</span>

        <span class="c1"># Handle NaN (return black)</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">return</span> <span class="s2">&quot;#000000&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>  <span class="c1"># Check for both int and float</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">palettet</span><span class="p">)</span>  <span class="c1"># Get color index using modulo arithmetic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>  <span class="c1"># Convert to string</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[\W_]+&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>  <span class="c1"># Remove non-alphanumeric characters</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">head</span><span class="p">:</span><span class="n">tail</span><span class="p">],</span> <span class="mi">36</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">palettet</span><span class="p">)</span>  <span class="c1"># Convert substring to a number base 36 (36 = 10 digits + 26 letters)</span>

        <span class="k">return</span> <span class="n">palettet</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_point</span><span class="p">(</span>
        <span class="n">row</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
        <span class="n">karta</span><span class="p">:</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">color_head</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">color_tail</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">popup_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a point (marker) to a Folium map based on the specified parameters and data in the provided row.</span>

<span class="sd">        The function attempts to extract coordinates from a geometry column if available, or directly from `x` and `y` columns</span>
<span class="sd">        (longitude and latitude). It then adds a circle marker to the Folium map (`karta`) using the specified color, radius,</span>
<span class="sd">        and other style parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row : pd.Series</span>
<span class="sd">            A row of data containing either a &#39;geometry&#39; attribute or x/y columns for coordinates.</span>

<span class="sd">        karta : folium.Map</span>
<span class="sd">            A Folium map object to which the marker will be added.</span>

<span class="sd">        color : str</span>
<span class="sd">            Specifies the color of the marker. If &quot;speed&quot; is passed, the marker color is determined by comparing</span>
<span class="sd">            the &#39;speed&#39; and &#39;speedlimit&#39; values in the row (e.g., blue for under the speed limit, black for very high speeds).</span>
<span class="sd">            Otherwise, it can be a column name in the `row` that determines the color based on the `color_head` and</span>
<span class="sd">            `color_tail` parameters to create a unique color from that column&#39;s value.</span>

<span class="sd">        color_head : int, optional</span>
<span class="sd">            Starting index for substring extraction from the `color` column value to create a unique color (default is None).</span>

<span class="sd">        color_tail : int, optional</span>
<span class="sd">            Ending index for substring extraction from the `color` column value to create a unique color (default is None).</span>

<span class="sd">        opacity : float, optional</span>
<span class="sd">            Opacity of the marker (default is 0.5).</span>

<span class="sd">        radius : int, optional</span>
<span class="sd">            Radius of the circle marker (default is 3).</span>

<span class="sd">        weight : int, optional</span>
<span class="sd">            Weight (thickness) of the circle marker&#39;s border (default is 6).</span>

<span class="sd">        popup_dict : dict, optional</span>
<span class="sd">            A dictionary where keys are labels and values are column names in the row. This dictionary is used to create</span>
<span class="sd">            an HTML popup with the specified labels and values (default is None).</span>

<span class="sd">        x : str, optional</span>
<span class="sd">            Column name for longitude, if &#39;geometry&#39; attribute is not present (default is None).</span>

<span class="sd">        y : str, optional</span>
<span class="sd">            Column name for latitude, if &#39;geometry&#39; attribute is not present (default is None).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The function modifies the Folium map in place and does not return anything.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; row = pd.Series({&quot;geometry&quot;: Point(40.748817, -73.985428), &quot;color&quot;: &quot;red&quot;})</span>
<span class="sd">        &gt;&gt;&gt; karta = folium.Map(location=[40.748817, -73.985428], zoom_start=12)</span>
<span class="sd">        &gt;&gt;&gt; Karta._add_point(row, karta, &quot;color&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Attempt to extract coordinates from the geometry column if present</span>
            <span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># If geometry is not present, use x and y columns for location</span>
            <span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">y</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>  <span class="c1"># x, y: lon, lat column names in DataFrame</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">location</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s2">&quot;speed&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">speedlimit</span><span class="p">)</span> <span class="ow">or</span> <span class="n">row</span><span class="o">.</span><span class="n">speedlimit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;purple&quot;</span>
            <span class="k">elif</span> <span class="n">row</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="o">.</span><span class="n">speedlimit</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
            <span class="k">elif</span> <span class="n">row</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">row</span><span class="o">.</span><span class="n">speedlimit</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span>
            <span class="k">elif</span> <span class="n">row</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">row</span><span class="o">.</span><span class="n">speedlimit</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;yellow&quot;</span>
            <span class="k">elif</span> <span class="n">row</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mf">1.3</span> <span class="o">*</span> <span class="n">row</span><span class="o">.</span><span class="n">speedlimit</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;orange&quot;</span>
            <span class="k">elif</span> <span class="n">row</span><span class="o">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mf">1.4</span> <span class="o">*</span> <span class="n">row</span><span class="o">.</span><span class="n">speedlimit</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
        <span class="c1"># Determine color if column is specified</span>
        <span class="k">elif</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>  <span class="c1"># color in DataFrame columns</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">_select_color</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">color</span><span class="p">],</span> <span class="n">color_head</span><span class="p">,</span> <span class="n">color_tail</span><span class="p">)</span>

        <span class="c1"># Create a popup HTML if popup_dict is provided</span>
        <span class="n">popup</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">: &lt;b&gt;</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="n">popup_dict</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span><span class="si">}</span><span class="s2">&lt;/b&gt;&lt;br&gt;&quot;</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">popup_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">popup_dict</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Add a CircleMarker to the map with the specified parameters</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">CircleMarker</span><span class="p">(</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">tooltip</span><span class="o">=</span><span class="n">popup</span>
        <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_line</span><span class="p">(</span>
        <span class="n">row</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
        <span class="n">karta</span><span class="p">:</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
        <span class="n">opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">popup_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a polyline (line) to a Folium map based on geometry data from a Pandas Series row.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row : pd.Series</span>
<span class="sd">            A Pandas Series containing a &#39;geometry&#39; column with a LineString object.</span>
<span class="sd">        karta : folium.Map</span>
<span class="sd">            The Folium map to which the polyline will be added.</span>
<span class="sd">        color : str, optional</span>
<span class="sd">            The color of the polyline. Defaults to &quot;blue&quot;.</span>
<span class="sd">        opacity : float, optional</span>
<span class="sd">            The opacity of the polyline (range: 0.0 to 1.0). Defaults to 0.5.</span>
<span class="sd">        weight : int, optional</span>
<span class="sd">            The thickness of the polyline in pixels. Defaults to 6.</span>
<span class="sd">        popup_dict : dict, optional</span>
<span class="sd">            A dictionary mapping column names to popup labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The function modifies the Folium map in place and does not return anything.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; row = pd.Series({&quot;geometry&quot;: LineString([(-74.006, 40.7128), (-73.9352, 40.7306)]), &quot;road_name&quot;: &quot;Broadway&quot;})</span>
<span class="sd">        &gt;&gt;&gt; karta = folium.Map(location=[40.72, -74.00], zoom_start=12)</span>
<span class="sd">        &gt;&gt;&gt; Karta._add_line(row, karta, color=&quot;red&quot;, popup_dict={&quot;Name&quot;: &quot;road_name&quot;})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">coords</span><span class="p">]</span>

        <span class="c1"># Handle color selection</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">_select_color</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">color</span><span class="p">])</span> <span class="k">if</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">index</span> <span class="k">else</span> <span class="n">color</span>

        <span class="c1"># Create popup if popup_dict is provided</span>
        <span class="n">popup</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">: &lt;b&gt;</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="n">popup_dict</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span><span class="si">}</span><span class="s2">&lt;/b&gt;&lt;br&gt;&quot;</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">popup_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">popup_dict</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Add polyline to the map</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">PolyLine</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">,</span> <span class="n">tooltip</span><span class="o">=</span><span class="n">popup</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_poly</span><span class="p">(</span>
        <span class="n">row</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
        <span class="n">karta</span><span class="p">:</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">,</span>
        <span class="n">fill_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="n">highlight_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
        <span class="n">fill_opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
        <span class="n">highlight_opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">line_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">popup_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a polygon to a Folium map based on the specified parameters and data in the provided row.</span>

<span class="sd">        This function creates a polygon (GeoJson) object for the specified row&#39;s geometry and adds it to the Folium map (`karta`).</span>
<span class="sd">        It allows customization of fill color, line width, and popups. The function also defines style and highlight properties</span>
<span class="sd">        for the polygon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row : pd.Series</span>
<span class="sd">            A row of data containing a &#39;geometry&#39; attribute that defines the polygon shape.</span>

<span class="sd">        karta : folium.Map</span>
<span class="sd">            A Folium map object to which the polygon will be added.</span>

<span class="sd">        fill_color : str</span>
<span class="sd">            Column name to determine the fill color of the polygon. If the column is present in the row, the color is extracted</span>
<span class="sd">            using the `_select_color` function.</span>

<span class="sd">        line_width : int</span>
<span class="sd">            The width of the border (outline) of the polygon.</span>

<span class="sd">        popup_dict : dict, optional</span>
<span class="sd">            A dictionary where keys are labels and values are column names in the row. This dictionary is used to create an</span>
<span class="sd">            HTML popup with the specified labels and values for the polygon (default is None).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The function modifies the Folium map in place and does not return anything.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; row = pd.Series({&quot;geometry&quot;: Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]), &quot;fill_color&quot;: &quot;blue&quot;})</span>
<span class="sd">        &gt;&gt;&gt; karta = folium.Map(location=[0.5, 0.5], zoom_start=10)</span>
<span class="sd">        &gt;&gt;&gt; Karta._add_poly(row, karta, &quot;fill_color&quot;, line_width=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine fill color if specified column is present</span>
        <span class="n">fill_color</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">_select_color</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">fill_color</span><span class="p">])</span> <span class="k">if</span> <span class="n">fill_color</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">index</span> <span class="k">else</span> <span class="n">fill_color</span>

        <span class="c1"># Style function to apply to the polygon</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">style_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;fillColor&quot;</span><span class="p">:</span> <span class="n">fill_color</span><span class="p">,</span>
                <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>  <span class="c1"># Border color</span>
                <span class="s2">&quot;fillOpacity&quot;</span><span class="p">:</span> <span class="n">fill_opacity</span><span class="p">,</span>
                <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">line_width</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="c1"># Highlight style function when the polygon is hovered over</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">highlight_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;fillColor&quot;</span><span class="p">:</span> <span class="n">highlight_color</span><span class="p">,</span>  <span class="c1"># fill_color,</span>
                <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>  <span class="c1"># Border color</span>
                <span class="s2">&quot;fillOpacity&quot;</span><span class="p">:</span> <span class="n">highlight_opacity</span><span class="p">,</span>
                <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">line_width</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="c1"># Create a popup if a popup dictionary is provided</span>
        <span class="n">popup</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">: &lt;b&gt;</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="n">popup_dict</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span><span class="si">}</span><span class="s2">&lt;/b&gt;&lt;br&gt;&quot;</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">popup_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">popup_dict</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Create a GeoJson object from the row&#39;s geometry and add it to the map</span>
        <span class="n">gjson</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">__geo_interface__</span>
        <span class="n">gjson</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">GeoJson</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">gjson</span><span class="p">,</span> <span class="n">style_function</span><span class="o">=</span><span class="n">style_function</span><span class="p">,</span> <span class="n">highlight_function</span><span class="o">=</span><span class="n">highlight_function</span><span class="p">,</span> <span class="n">tooltip</span><span class="o">=</span><span class="n">popup</span><span class="p">)</span>
        <span class="n">gjson</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

<div class="viewcode-block" id="Karta.plp">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.Karta.plp">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plp</span><span class="p">(</span>
        <span class="n">gdf_list</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Point</span>
        <span class="n">cluster</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">heatmap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">line</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">antpath</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">point_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
        <span class="n">color_head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">color_tail</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">point_opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">point_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">point_weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">point_popup</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ring_inner_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ring_outer_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># LineString</span>
        <span class="n">line_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
        <span class="n">line_opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">line_weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">line_popup</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Polygon</span>
        <span class="n">centroid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># if True it shows centroids of polygons on the map.</span>
        <span class="n">fill_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="n">highlight_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
        <span class="n">fill_opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
        <span class="n">highlight_opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">line_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">poly_popup</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">geohash_res</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">s2_res</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">h3_res</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">geohash_inner</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">compact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="c1"># Cells and OSM objects</span>
        <span class="n">cells</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cell_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># list of geohash, S2 or H3 cell IDs</span>
        <span class="n">osm_ways</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># list of OSM way IDs (lines or polygons) and Overpass API URL to query from</span>
        <span class="n">url</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;https://overpass-api.de/api/interpreter&quot;</span><span class="p">,</span>  <span class="c1"># OpenStreetMap server URL</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plp (points, lines, polygons) creates a Folium map with points, lines, or polygons based on the input geospatial data.</span>
<span class="sd">        The function `plp` allows users to add different geometrical elements (points, lines, polygons) to a Folium map.</span>
<span class="sd">        It supports various visual styles and configurations, such as clustering, heatmaps, and geohash or cell-based layers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf_list : list of gpd.GeoDataFrame or pd.DataFrame, optional</span>
<span class="sd">            List of GeoDataFrames or DataFrames containing geometrical data to be plotted. If a single DataFrame is provided,</span>
<span class="sd">            it will be wrapped in a list internally.</span>

<span class="sd">        cluster : bool, default False</span>
<span class="sd">            If True, clusters points together based on their proximity using Folium&#39;s `MarkerCluster`.</span>

<span class="sd">        heatmap : bool, default False</span>
<span class="sd">            If True, creates a heatmap layer using Folium&#39;s `HeatMap` for points.</span>

<span class="sd">        line : bool, default False</span>
<span class="sd">            If True, connects points using Folium&#39;s `PolyLine` to form lines.</span>

<span class="sd">        antpath : bool, default False</span>
<span class="sd">            If True, creates animated ant paths for the line geometries using Folium&#39;s `AntPath`.</span>

<span class="sd">        point_color : str, default &quot;blue&quot;</span>
<span class="sd">            Color of the points when displayed on the map.</span>

<span class="sd">        color_head : str, optional</span>
<span class="sd">            Substring index for the head to extract color.</span>

<span class="sd">        color_tail : str, optional</span>
<span class="sd">            Substring index for the tail to extract color.</span>

<span class="sd">        point_opacity : float, default 0.5</span>
<span class="sd">            Opacity of the points. Value should be between 0 and 1.</span>

<span class="sd">        point_radius : int, default 3</span>
<span class="sd">            Radius of the points in pixels.</span>

<span class="sd">        point_weight : int, default 6</span>
<span class="sd">            Weight (thickness) of the point outline. Typically set to twice the `point_radius`.</span>

<span class="sd">        point_popup : dict, optional</span>
<span class="sd">            Dictionary where keys are labels and values are column names in the DataFrame. Used to create HTML popups with</span>
<span class="sd">            attributes of each point.</span>

<span class="sd">        buffer_radius : float, default 0</span>
<span class="sd">            Buffer radius (in meters) to create a buffer around each point. Set to 0 to disable buffering.</span>

<span class="sd">        ring_inner_radius : float, default 0</span>
<span class="sd">            Inner radius of ring buffers around points. Only used if `ring_outer_radius` is set.</span>

<span class="sd">        ring_outer_radius : float, default 0</span>
<span class="sd">            Outer radius of ring buffers around points. If set, creates a ring around each point.</span>

<span class="sd">        x : str, optional</span>
<span class="sd">            Column name for the x-coordinate (longitude). Specify it to use the column other than that containing &#39;lon&#39;.</span>

<span class="sd">        y : str, optional</span>
<span class="sd">            Column name for the y-coordinate (latitude). Specify it to use the column other than that containing &#39;lat&#39;.</span>

<span class="sd">        line_color : str, default &quot;blue&quot;</span>
<span class="sd">            Color of the lines connecting points or LineString geometries.</span>

<span class="sd">        line_opacity : float, default 0.5</span>
<span class="sd">            Opacity of the lines. Value should be between 0 and 1.</span>

<span class="sd">        line_weight : int, default 6</span>
<span class="sd">            Thickness of the lines.</span>

<span class="sd">        line_popup : dict, optional</span>
<span class="sd">            Dictionary where keys are labels and values are column names in the DataFrame. Used to create HTML popups with</span>
<span class="sd">            attributes of each line.</span>

<span class="sd">        centroid : bool, default False</span>
<span class="sd">            If True, displays the centroids of polygon geometries on the map.</span>

<span class="sd">        fill_color : str, default &quot;red&quot;</span>
<span class="sd">            Fill color for polygon geometries.</span>

<span class="sd">        highlight_color : str, default &quot;green&quot;</span>
<span class="sd">            Color used to highlight polygons when hovered.</span>

<span class="sd">        line_width : float, default 0.3</span>
<span class="sd">            Thickness of polygon outlines.</span>

<span class="sd">        poly_popup : dict, optional</span>
<span class="sd">            Dictionary where keys are labels and values are column names in the DataFrame. Used to create HTML popups with</span>
<span class="sd">            attributes of each polygon.</span>

<span class="sd">        geohash_res : int, default 0</span>
<span class="sd">            Resolution for creating geohash-based polygonal layers. Set to 0 to disable.</span>

<span class="sd">        s2_res : int, default -1</span>
<span class="sd">            Resolution for creating S2-based polygonal layers. Set to -1 to disable.</span>

<span class="sd">        h3_res : int, default -1</span>
<span class="sd">            Resolution for creating H3-based polygonal layers. Set to -1 to disable.</span>

<span class="sd">        geohash_inner : bool, default False</span>
<span class="sd">            If True, shows only inner geohash cells. Does not work if `compact` is set to True.</span>

<span class="sd">        compact : bool, default False</span>
<span class="sd">            If True, creates compact representation of geohash, S2, or H3 cells.</span>

<span class="sd">        cells : list, optional</span>
<span class="sd">            List of geohash, S2, or H3 cell IDs to visualize.</span>

<span class="sd">        cell_type : str, optional</span>
<span class="sd">            Type of cells used in `cells` parameter. Can be &#39;geohash&#39;, &#39;s2&#39;, or &#39;h3&#39;.</span>

<span class="sd">        osm_ways : list of int, optional</span>
<span class="sd">            List of OSM way IDs to visualize as lines or polygons.</span>

<span class="sd">        url : str, optional</span>
<span class="sd">            Overpass API URL to query OSM geometries by `osm_ways` parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        folium.Map</span>
<span class="sd">            A Folium map object with the added geometrical features based on input parameters.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Example usage</span>
<span class="sd">        &gt;&gt;&gt; gdf = gpd.read_file(&quot;path/to/shapefile.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plp(gdf)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Handle `cells` input by converting cell IDs to geometries</span>
        <span class="k">if</span> <span class="n">cells</span><span class="p">:</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">geoms</span> <span class="o">=</span> <span class="n">SpatialIndex</span><span class="o">.</span><span class="n">cell_poly</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="n">cell_type</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">cells</span><span class="p">,</span> <span class="s2">&quot;res&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geoms</span><span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
            <span class="n">karta</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">plp</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">poly_popup</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;Resolution&quot;</span><span class="p">:</span> <span class="s2">&quot;res&quot;</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">karta</span>

        <span class="c1"># Handle `osm_ways` input by converting OSM way IDs to geometries</span>
        <span class="k">if</span> <span class="n">osm_ways</span><span class="p">:</span>
            <span class="n">geoms</span> <span class="o">=</span> <span class="n">OSMUtils</span><span class="o">.</span><span class="n">ways_to_geom</span><span class="p">(</span><span class="n">osm_ways</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;way_id&quot;</span><span class="p">:</span> <span class="n">osm_ways</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geoms</span><span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LineString</span><span class="p">):</span>
                <span class="n">karta</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">plp</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">line_popup</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;way_id&quot;</span><span class="p">:</span> <span class="s2">&quot;way_id&quot;</span><span class="p">},</span> <span class="n">line_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">karta</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">plp</span><span class="p">(</span>
                    <span class="n">gdf</span><span class="p">,</span>
                    <span class="n">geohash_res</span><span class="o">=</span><span class="n">geohash_res</span><span class="p">,</span>
                    <span class="n">s2_res</span><span class="o">=</span><span class="n">s2_res</span><span class="p">,</span>
                    <span class="n">h3_res</span><span class="o">=</span><span class="n">h3_res</span><span class="p">,</span>
                    <span class="n">geohash_inner</span><span class="o">=</span><span class="n">geohash_inner</span><span class="p">,</span>
                    <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">,</span>
                    <span class="n">poly_popup</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;way_id&quot;</span><span class="p">:</span> <span class="s2">&quot;way_id&quot;</span><span class="p">},</span>
                    <span class="n">fill_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">karta</span>

        <span class="c1"># Ensure `gdf_list` is always a list of GeoDataFrames or DataFrames</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf_list</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">gdf_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">gdf_list</span><span class="p">]</span>

        <span class="c1"># Initialize bounding box coordinates for the map</span>
        <span class="n">minlat</span><span class="p">,</span> <span class="n">maxlat</span><span class="p">,</span> <span class="n">minlon</span><span class="p">,</span> <span class="n">maxlon</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">180</span>

        <span class="n">easting</span><span class="p">,</span> <span class="n">northing</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
        <span class="c1"># Iterate through the list of GeoDataFrames to update bounding box</span>
        <span class="k">for</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">gdf_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>  <span class="c1"># if pd.DataFrame</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>  <span class="c1"># if x is not specified, determine longitude and latitude columns</span>
                    <span class="n">easting</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s2">&quot;lon&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">or</span> <span class="s2">&quot;lng&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">northing</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s2">&quot;lat&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">lons</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">easting</span><span class="p">]</span>
                <span class="n">lats</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">northing</span><span class="p">]</span>
                <span class="n">minlatg</span><span class="p">,</span> <span class="n">minlong</span><span class="p">,</span> <span class="n">maxlatg</span><span class="p">,</span> <span class="n">maxlong</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>  <span class="c1"># minlatg: minlat in gdf</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># If input is a GeoDataFrame, use total_bounds to get the bounding box</span>
                <span class="n">minlong</span><span class="p">,</span> <span class="n">minlatg</span><span class="p">,</span> <span class="n">maxlong</span><span class="p">,</span> <span class="n">maxlatg</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>
            <span class="c1"># Update overall bounding box</span>
            <span class="n">minlat</span><span class="p">,</span> <span class="n">minlon</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minlat</span><span class="p">,</span> <span class="n">minlatg</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">minlon</span><span class="p">,</span> <span class="n">minlong</span><span class="p">)</span>
            <span class="n">maxlat</span><span class="p">,</span> <span class="n">maxlon</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxlat</span><span class="p">,</span> <span class="n">maxlatg</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxlon</span><span class="p">,</span> <span class="n">maxlong</span><span class="p">)</span>

        <span class="c1"># Create a base map using the bounding box</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="p">[</span><span class="n">minlat</span><span class="p">,</span> <span class="n">minlon</span><span class="p">]</span>  <span class="c1"># South West (bottom left corner)</span>
        <span class="n">ne</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxlat</span><span class="p">,</span> <span class="n">maxlon</span><span class="p">]</span>  <span class="c1"># North East (top right corner)</span>
        <span class="n">karta</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">_base_map</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">ne</span><span class="p">)</span>  <span class="c1"># Initialize folium map with the bounding box</span>

        <span class="c1"># Iterate through each DataFrame or GeoDataFrame in the list to add layers to the map</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gdf_list</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="c1"># Handle Polygon geometries</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="n">group_polygon</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Polygon&quot;</span><span class="p">)</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                    <span class="n">Karta</span><span class="o">.</span><span class="n">_add_poly</span><span class="p">,</span>
                    <span class="n">karta</span><span class="o">=</span><span class="n">group_polygon</span><span class="p">,</span>
                    <span class="n">fill_color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span>
                    <span class="n">highlight_color</span><span class="o">=</span><span class="n">highlight_color</span><span class="p">,</span>
                    <span class="n">fill_opacity</span><span class="o">=</span><span class="n">fill_opacity</span><span class="p">,</span>
                    <span class="n">highlight_opacity</span><span class="o">=</span><span class="n">highlight_opacity</span><span class="p">,</span>
                    <span class="n">line_width</span><span class="o">=</span><span class="n">line_width</span><span class="p">,</span>
                    <span class="n">popup_dict</span><span class="o">=</span><span class="n">poly_popup</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">group_polygon</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">centroid</span><span class="p">:</span>  <span class="c1"># Show centroids of polygons if `centroid=True`</span>
                    <span class="n">group_centroid</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Centroid&quot;</span><span class="p">)</span>
                    <span class="n">cdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">gdf</span><span class="o">.</span><span class="n">centroid</span><span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>  <span class="c1"># centroid df</span>
                    <span class="n">cdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Karta</span><span class="o">.</span><span class="n">_add_point</span><span class="p">,</span> <span class="n">karta</span><span class="o">=</span><span class="n">group_centroid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">group_centroid</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>
            <span class="c1"># Handle LineString geometries</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">LineString</span><span class="p">):</span>
                <span class="n">group_line</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Line&quot;</span><span class="p">)</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                    <span class="n">Karta</span><span class="o">.</span><span class="n">_add_line</span><span class="p">,</span>
                    <span class="n">karta</span><span class="o">=</span><span class="n">group_line</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="p">,</span>
                    <span class="n">opacity</span><span class="o">=</span><span class="n">line_opacity</span><span class="p">,</span>
                    <span class="n">weight</span><span class="o">=</span><span class="n">line_weight</span><span class="p">,</span>
                    <span class="n">popup_dict</span><span class="o">=</span><span class="n">line_popup</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">group_line</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

            <span class="c1"># Handle DataFrame or Point geometry</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># if not isinstance(gdf, gpd.GeoDataFrame) or isinstance(geom, Point):</span>
                <span class="n">group_point</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Point&quot;</span><span class="p">)</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                    <span class="n">Karta</span><span class="o">.</span><span class="n">_add_point</span><span class="p">,</span>
                    <span class="n">karta</span><span class="o">=</span><span class="n">group_point</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">point_color</span><span class="p">,</span>
                    <span class="n">color_head</span><span class="o">=</span><span class="n">color_head</span><span class="p">,</span>
                    <span class="n">color_tail</span><span class="o">=</span><span class="n">color_tail</span><span class="p">,</span>
                    <span class="n">opacity</span><span class="o">=</span><span class="n">point_opacity</span><span class="p">,</span>
                    <span class="n">radius</span><span class="o">=</span><span class="n">point_radius</span><span class="p">,</span>
                    <span class="n">weight</span><span class="o">=</span><span class="n">point_weight</span><span class="p">,</span>
                    <span class="n">popup_dict</span><span class="o">=</span><span class="n">point_popup</span><span class="p">,</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">easting</span><span class="p">,</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">northing</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">point_color</span> <span class="o">==</span> <span class="s2">&quot;speed&quot;</span><span class="p">:</span>
                    <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    {% macro html(this, kwargs) %}</span>

<span class="s2">                    &lt;!doctype html&gt;</span>
<span class="s2">                    &lt;html lang=&quot;en&quot;&gt;</span>
<span class="s2">                    &lt;head&gt;</span>
<span class="s2">                      &lt;meta charset=&quot;utf-8&quot;&gt;</span>
<span class="s2">                      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span>
<span class="s2">                      &lt;title&gt;jQuery UI Draggable - Default functionality&lt;/title&gt;</span>
<span class="s2">                      &lt;link rel=&quot;stylesheet&quot; href=&quot;//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css&quot;&gt;</span>

<span class="s2">                      &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;</span>
<span class="s2">                      &lt;script src=&quot;https://code.jquery.com/ui/1.12.1/jquery-ui.js&quot;&gt;&lt;/script&gt;</span>

<span class="s2">                      &lt;script&gt;</span>
<span class="s2">                      $( function() {</span>
<span class="s2">                        $( &quot;#maplegend&quot; ).draggable({</span>
<span class="s2">                                        start: function (event, ui) {</span>
<span class="s2">                                            $(this).css({</span>
<span class="s2">                                                right: &quot;auto&quot;,</span>
<span class="s2">                                                top: &quot;auto&quot;,</span>
<span class="s2">                                                bottom: &quot;auto&quot;</span>
<span class="s2">                                            });</span>
<span class="s2">                                        }</span>
<span class="s2">                                    });</span>
<span class="s2">                    });</span>

<span class="s2">                      &lt;/script&gt;</span>
<span class="s2">                    &lt;/head&gt;</span>
<span class="s2">                    &lt;body&gt;</span>


<span class="s2">                    &lt;div id=&#39;maplegend&#39; class=&#39;maplegend&#39;</span>
<span class="s2">                        style=&#39;position: absolute; z-index:9999; border:2px solid grey; background-color:rgba(255, 255, 255, 1);</span>
<span class="s2">                         border-radius:6px; padding: 10px; font-size:14px; right: 95px; top: 10px;&#39;&gt;</span>

<span class="s2">                    &lt;!-- The next line is a comment --&gt;</span>
<span class="s2">                    &lt;!-- &lt;div class=&#39;legend-title&#39;&gt;Legend (draggable!)&lt;/div&gt; --&gt;</span>
<span class="s2">                    &lt;div class=&#39;legend-scale&#39;&gt;</span>
<span class="s2">                      &lt;ul class=&#39;legend-labels&#39;&gt;</span>
<span class="s2">                        &lt;li&gt;&lt;span style=&#39;background:black;&#39;&gt;&lt;/span&gt;Speeding ≥ 40% &lt;/li&gt;</span>
<span class="s2">                        &lt;li&gt;&lt;span style=&#39;background:red;&#39;&gt;&lt;/span&gt;30% ≤ Speeding &lt; 40%&lt;/li&gt;</span>
<span class="s2">                        &lt;li&gt;&lt;span style=&#39;background:orange;&#39;&gt;&lt;/span&gt;20% ≤ Speeding &lt; 30%&lt;/li&gt;</span>
<span class="s2">                        &lt;li&gt;&lt;span style=&#39;background:yellow;&#39;&gt;&lt;/span&gt;10% ≤ Speeding &lt; 20%&lt;/li&gt;</span>
<span class="s2">                        &lt;li&gt;&lt;span style=&#39;background:green;&#39;&gt;&lt;/span&gt;0 &lt; Speeding &lt; 10%&lt;/li&gt;</span>
<span class="s2">                        &lt;li&gt;&lt;span style=&#39;background:blue;&#39;&gt;&lt;/span&gt;No speeding&lt;/li&gt;</span>
<span class="s2">                        &lt;li&gt;&lt;span style=&#39;background:purple;&#39;  &gt;&lt;/span&gt;Speed limit unavailable&lt;/li&gt;</span>
<span class="s2">                      &lt;/ul&gt;</span>
<span class="s2">                    &lt;/div&gt;</span>
<span class="s2">                    &lt;/div&gt;</span>

<span class="s2">                    &lt;/body&gt;</span>
<span class="s2">                    &lt;/html&gt;</span>

<span class="s2">                    &lt;style type=&#39;text/css&#39;&gt;</span>
<span class="s2">                      .maplegend .legend-title {</span>
<span class="s2">                        text-align: left;</span>
<span class="s2">                        margin-bottom: 0;</span>
<span class="s2">                        font-weight: bold;</span>
<span class="s2">                        font-size: 90%;</span>
<span class="s2">                        }</span>
<span class="s2">                      .maplegend .legend-scale ul {</span>
<span class="s2">                        margin: 0;</span>
<span class="s2">                        margin-bottom: 0;</span>
<span class="s2">                        padding: 0;</span>
<span class="s2">                        float: left;</span>
<span class="s2">                        list-style: none;</span>
<span class="s2">                        }</span>
<span class="s2">                      .maplegend .legend-scale ul li {</span>
<span class="s2">                        font-size: 80%;</span>
<span class="s2">                        list-style: none;</span>
<span class="s2">                        margin-left: 0;</span>
<span class="s2">                        line-height: 18px;</span>
<span class="s2">                        margin-bottom: 1px;</span>
<span class="s2">                        }</span>
<span class="s2">                      .maplegend ul.legend-labels li span {</span>
<span class="s2">                        display: block;</span>
<span class="s2">                        float: left;</span>
<span class="s2">                        height: 16px;</span>
<span class="s2">                        width: 30px;</span>
<span class="s2">                        margin-right: 5px;</span>
<span class="s2">                        margin-left: 0;</span>
<span class="s2">                        border: 1px solid #999;</span>
<span class="s2">                        }</span>
<span class="s2">                      .maplegend .legend-source {</span>
<span class="s2">                        font-size: 80%;</span>
<span class="s2">                        color: #777;</span>
<span class="s2">                        clear: both;</span>
<span class="s2">                        }</span>
<span class="s2">                      .maplegend a {</span>
<span class="s2">                        color: #777;</span>
<span class="s2">                        }</span>
<span class="s2">                    &lt;/style&gt;</span>
<span class="s2">                    {</span><span class="si">% e</span><span class="s2">ndmacro %}&quot;&quot;&quot;</span>

                    <span class="n">macro</span> <span class="o">=</span> <span class="n">MacroElement</span><span class="p">()</span>
                    <span class="n">macro</span><span class="o">.</span><span class="n">_template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
                    <span class="n">karta</span><span class="o">.</span><span class="n">get_root</span><span class="p">()</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">macro</span><span class="p">)</span>

                <span class="n">group_point</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

                <span class="c1"># Add clustering, heatmap, line connections, and buffer/ring visualizations as specified</span>

                <span class="c1"># Create a clustering layer if `cluster=True`</span>
                <span class="k">if</span> <span class="n">cluster</span><span class="p">:</span>
                    <span class="n">group_cluster</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Cluster&quot;</span><span class="p">)</span>
                    <span class="c1"># If the input is a regular DataFrame, use the latitude and longitude columns</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
                        <span class="n">group_cluster</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">plugins</span><span class="o">.</span><span class="n">MarkerCluster</span><span class="p">(</span><span class="n">locations</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">))))</span>
                    <span class="c1"># If it&#39;s a GeoDataFrame, use geometry coordinates</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">group_cluster</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">plugins</span><span class="o">.</span><span class="n">MarkerCluster</span><span class="p">(</span><span class="n">locations</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">))))</span>
                    <span class="c1"># Add the clustering layer to the map</span>
                    <span class="n">group_cluster</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

                <span class="c1"># Create a heatmap layer if `heatmap=True`</span>
                <span class="k">if</span> <span class="n">heatmap</span><span class="p">:</span>
                    <span class="n">group_heatmap</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Heatmap&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
                        <span class="n">group_heatmap</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">plugins</span><span class="o">.</span><span class="n">HeatMap</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">group_heatmap</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">plugins</span><span class="o">.</span><span class="n">HeatMap</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">)),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
                    <span class="n">group_heatmap</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

                <span class="c1"># Create a line connection layer if `line=True`</span>
                <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">group_line</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Line&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
                        <span class="n">group_line</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span>
                            <span class="n">folium</span><span class="o">.</span><span class="n">PolyLine</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">line_weight</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="n">line_opacity</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">group_line</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span>
                            <span class="n">folium</span><span class="o">.</span><span class="n">PolyLine</span><span class="p">(</span>
                                <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">)),</span>
                                <span class="n">color</span><span class="o">=</span><span class="n">line_color</span><span class="p">,</span>
                                <span class="n">weight</span><span class="o">=</span><span class="n">line_weight</span><span class="p">,</span>
                                <span class="n">opacity</span><span class="o">=</span><span class="n">line_opacity</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="c1"># Add the line layer to the map</span>
                    <span class="n">group_line</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

                <span class="c1"># Create an animated path layer using AntPath if `antpath=True`</span>
                <span class="k">if</span> <span class="n">antpath</span><span class="p">:</span>
                    <span class="n">group_antpath</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Ant Path&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
                        <span class="n">group_antpath</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">plugins</span><span class="o">.</span><span class="n">AntPath</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">))))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">group_antpath</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">plugins</span><span class="o">.</span><span class="n">AntPath</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">))))</span>
                    <span class="n">group_antpath</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

                <span class="c1"># Create a buffer visualization if `buffer_radius &gt; 0`</span>
                <span class="k">if</span> <span class="n">buffer_radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">group_buffer</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Buffer&quot;</span><span class="p">)</span>
                    <span class="n">bgdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># buffered gdf: Create a copy of the GeoDataFrame to modify geometries</span>
                    <span class="c1"># Apply buffer to geometries using the specified radius in meters</span>
                    <span class="n">bgdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">bgdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">GeomUtils</span><span class="o">.</span><span class="n">find_proj</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_radius</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="c1"># Add the buffered geometries to the map as polygons</span>
                    <span class="n">bgdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="n">Karta</span><span class="o">.</span><span class="n">_add_poly</span><span class="p">,</span>
                        <span class="n">karta</span><span class="o">=</span><span class="n">group_buffer</span><span class="p">,</span>
                        <span class="n">fill_color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span>
                        <span class="n">highlight_color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span>
                        <span class="n">popup_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># Add the buffer layer to the map</span>
                    <span class="n">group_buffer</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

                <span class="c1"># Create ring visualization if `ring_outer_radius &gt; 0`</span>
                <span class="k">if</span> <span class="n">ring_outer_radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">group_ring</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">- Ring&quot;</span><span class="p">)</span>
                    <span class="n">bgdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># buffered gdf: Create a copy of the GeoDataFrame to modify geometries</span>
                    <span class="c1"># Create ring shapes by applying an outer and inner buffer, subtracting the inner from the outer</span>
                    <span class="n">bgdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">bgdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">GeomUtils</span><span class="o">.</span><span class="n">find_proj</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">ring_outer_radius</span><span class="p">)</span>
                        <span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">bgdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">GeomUtils</span><span class="o">.</span><span class="n">find_proj</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">ring_inner_radius</span><span class="p">))</span>
                        <span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>
                    <span class="p">)</span>  <span class="c1"># radius in meters</span>
                    <span class="c1"># Add the ring-shaped geometries to the map as polygons</span>
                    <span class="n">bgdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="n">Karta</span><span class="o">.</span><span class="n">_add_poly</span><span class="p">,</span>
                        <span class="n">karta</span><span class="o">=</span><span class="n">group_ring</span><span class="p">,</span>
                        <span class="n">fill_color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span>
                        <span class="n">highlight_color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span>
                        <span class="n">popup_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># Add the ring layer to the map</span>
                    <span class="n">group_ring</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

        <span class="c1"># Geohash visualization if `geohash_res &gt; 0`</span>
        <span class="k">if</span> <span class="n">geohash_res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># inner=False doesn&#39;t work if compact=True</span>
            <span class="c1"># Create a polygon for bounding box if input is not a polygon</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="n">cdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bb</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">],</span> <span class="p">[</span><span class="n">maxlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">],</span> <span class="p">[</span><span class="n">maxlon</span><span class="p">,</span> <span class="n">maxlat</span><span class="p">],</span> <span class="p">[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">maxlat</span><span class="p">],</span> <span class="p">[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">]])</span>
                <span class="n">cdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">bb</span><span class="p">]},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>  <span class="c1"># Create a bounding box GeoDataFrame</span>

            <span class="c1"># Convert geometries to geohash cells and their geometries</span>
            <span class="n">cells</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">SpatialIndex</span><span class="o">.</span><span class="n">ppoly_cell</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="s2">&quot;geohash&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">geohash_res</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">geoms</span> <span class="o">=</span> <span class="n">SpatialIndex</span><span class="o">.</span><span class="n">cell_poly</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="s2">&quot;geohash&quot;</span><span class="p">)</span>
            <span class="n">cdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">cells</span><span class="p">,</span> <span class="s2">&quot;res&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geoms</span><span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>

            <span class="c1"># Add geohash cells to the map as a polygon layer</span>
            <span class="n">group_geohash</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> - Geohash&quot;</span><span class="p">)</span>

            <span class="n">cdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="n">Karta</span><span class="o">.</span><span class="n">_add_poly</span><span class="p">,</span>
                <span class="n">karta</span><span class="o">=</span><span class="n">group_geohash</span><span class="p">,</span>
                <span class="n">fill_color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span>
                <span class="n">highlight_color</span><span class="o">=</span><span class="n">highlight_color</span><span class="p">,</span>
                <span class="n">popup_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;Resolution&quot;</span><span class="p">:</span> <span class="s2">&quot;res&quot;</span><span class="p">},</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">group_geohash</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

        <span class="c1"># S2 cell visualization if `s2_res &gt; -1`</span>
        <span class="k">if</span> <span class="n">s2_res</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Create a polygon for bounding box if input is not a polygon</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="n">cdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bb</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">],</span> <span class="p">[</span><span class="n">maxlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">],</span> <span class="p">[</span><span class="n">maxlon</span><span class="p">,</span> <span class="n">maxlat</span><span class="p">],</span> <span class="p">[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">maxlat</span><span class="p">],</span> <span class="p">[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">]])</span>
                <span class="n">cdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">bb</span><span class="p">]},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>  <span class="c1"># cell df</span>

            <span class="c1"># Convert geometries to S2 cells and their geometries</span>
            <span class="n">cells</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">SpatialIndex</span><span class="o">.</span><span class="n">ppoly_cell</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="s2">&quot;s2&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">s2_res</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">geoms</span> <span class="o">=</span> <span class="n">SpatialIndex</span><span class="o">.</span><span class="n">cell_poly</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="s2">&quot;s2&quot;</span><span class="p">)</span>
            <span class="n">cdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">cells</span><span class="p">,</span> <span class="s2">&quot;res&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geoms</span><span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>

            <span class="c1"># Add S2 cells to the map as a polygon layer</span>
            <span class="n">group_s2</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> - S2&quot;</span><span class="p">)</span>
            <span class="n">cdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="n">Karta</span><span class="o">.</span><span class="n">_add_poly</span><span class="p">,</span>
                <span class="n">karta</span><span class="o">=</span><span class="n">group_s2</span><span class="p">,</span>
                <span class="n">fill_color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span>
                <span class="n">highlight_color</span><span class="o">=</span><span class="n">highlight_color</span><span class="p">,</span>
                <span class="n">popup_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;Resolution&quot;</span><span class="p">:</span> <span class="s2">&quot;res&quot;</span><span class="p">},</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">group_s2</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

        <span class="c1"># H3 cell visualization if `h3_res &gt; -1`</span>
        <span class="k">if</span> <span class="n">h3_res</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="n">cdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Create a bounding box GeoDataFrame</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bb</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">],</span> <span class="p">[</span><span class="n">maxlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">],</span> <span class="p">[</span><span class="n">maxlon</span><span class="p">,</span> <span class="n">maxlat</span><span class="p">],</span> <span class="p">[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">maxlat</span><span class="p">],</span> <span class="p">[</span><span class="n">minlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">]])</span>
                <span class="n">cdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">bb</span><span class="p">]},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>  <span class="c1"># cell df</span>

            <span class="c1"># Convert geometries to H3 cells and their geometries</span>
            <span class="n">cells</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">SpatialIndex</span><span class="o">.</span><span class="n">ppoly_cell</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="s2">&quot;h3&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">h3_res</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span>
            <span class="n">res</span><span class="p">,</span> <span class="n">geoms</span> <span class="o">=</span> <span class="n">SpatialIndex</span><span class="o">.</span><span class="n">cell_poly</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="s2">&quot;h3&quot;</span><span class="p">)</span>
            <span class="n">cdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">cells</span><span class="p">,</span> <span class="s2">&quot;res&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geoms</span><span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>

            <span class="c1"># Add H3 cells to the map as a polygon layer</span>
            <span class="n">group_h3</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> - H3&quot;</span><span class="p">)</span>
            <span class="n">cdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="n">Karta</span><span class="o">.</span><span class="n">_add_poly</span><span class="p">,</span>
                <span class="n">karta</span><span class="o">=</span><span class="n">group_h3</span><span class="p">,</span>
                <span class="n">fill_color</span><span class="o">=</span><span class="n">fill_color</span><span class="p">,</span>
                <span class="n">highlight_color</span><span class="o">=</span><span class="n">highlight_color</span><span class="p">,</span>
                <span class="n">popup_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID&quot;</span><span class="p">:</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;Resolution&quot;</span><span class="p">:</span> <span class="s2">&quot;res&quot;</span><span class="p">},</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">group_h3</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">LayerControl</span><span class="p">(</span><span class="n">collapsed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">karta</span></div>


<div class="viewcode-block" id="Karta.choropleth">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.Karta.choropleth">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">choropleth</span><span class="p">(</span>
        <span class="n">gdf</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">bins</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">legend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">palette</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;YlOrRd&quot;</span><span class="p">,</span> <span class="n">highlight</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a choropleth map using the given GeoDataFrame and specified parameters.</span>

<span class="sd">        This function generates a Folium choropleth map layer by visualizing the data from a GeoDataFrame using color gradients</span>
<span class="sd">        to represent different data values across geographic areas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf : geopandas.GeoDataFrame</span>
<span class="sd">            The GeoDataFrame containing multipolygon geometries and data attributes to be visualized.</span>
<span class="sd">        columns : list</span>
<span class="sd">            A list of two elements:</span>
<span class="sd">                - columns[0] : str</span>
<span class="sd">                    The column name in `gdf` that contains unique identifiers for each region.</span>
<span class="sd">                - columns[1] : str</span>
<span class="sd">                    The column name in `gdf` containing the data values to be visualized.</span>
<span class="sd">        bins : list</span>
<span class="sd">            A list of numerical values defining the value intervals for the choropleth color categories.</span>
<span class="sd">        legend : str</span>
<span class="sd">            The title for the legend, which describes what is represented on the map.</span>
<span class="sd">        palette : str, optional</span>
<span class="sd">            The color palette to be used for the choropleth (default is &quot;YlOrRd&quot;).</span>
<span class="sd">        highlight : bool, optional</span>
<span class="sd">            A flag indicating whether regions should be highlighted when hovered over (default is True).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        folium.Map</span>
<span class="sd">            The Folium map object containing the choropleth layer.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; choropleth(</span>
<span class="sd">                gdf,</span>
<span class="sd">                [&#39;region_id&#39;, &#39;population&#39;],</span>
<span class="sd">                bins=[0, 100, 500, 1000, 5000],</span>
<span class="sd">                legend=&quot;Population by Region&quot;,</span>
<span class="sd">                palette=&quot;YlOrRd&quot;,</span>
<span class="sd">                highlight=True</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the bounding coordinates of the GeoDataFrame</span>
        <span class="n">minlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">,</span> <span class="n">maxlon</span><span class="p">,</span> <span class="n">maxlat</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>  <span class="c1"># Get the total bounds of the GeoDataFrame</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="p">[</span><span class="n">minlat</span><span class="p">,</span> <span class="n">minlon</span><span class="p">]</span>  <span class="c1"># South-west corner</span>
        <span class="n">ne</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxlat</span><span class="p">,</span> <span class="n">maxlon</span><span class="p">]</span>  <span class="c1"># North-east corner</span>
        <span class="n">karta</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">_base_map</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">ne</span><span class="p">)</span>  <span class="c1"># Create a base map using the bounding coordinates</span>

        <span class="c1"># Create a choropleth layer based on the GeoDataFrame</span>
        <span class="n">choropleth</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">Choropleth</span><span class="p">(</span>
            <span class="n">geo_data</span><span class="o">=</span><span class="n">gdf</span><span class="p">,</span>  <span class="c1"># The GeoDataFrame containing geographic data</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Choropleth&quot;</span><span class="p">,</span>  <span class="c1"># Name of the layer for display in layer control</span>
            <span class="n">data</span><span class="o">=</span><span class="n">gdf</span><span class="p">,</span>  <span class="c1"># The data source for values to be represented</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>  <span class="c1"># [unique_identifier_column, data_value_column] for matching regions with data</span>
            <span class="n">key_on</span><span class="o">=</span><span class="s2">&quot;feature.properties.&quot;</span> <span class="o">+</span> <span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># Key to match GeoDataFrame regions with the data</span>
            <span class="n">legend_name</span><span class="o">=</span><span class="n">legend</span><span class="p">,</span>  <span class="c1"># Description of the data being visualized</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span>  <span class="c1"># Value ranges for choropleth colors</span>
            <span class="n">fill_color</span><span class="o">=</span><span class="n">palette</span><span class="p">,</span>  <span class="c1"># Color scheme for the choropleth</span>
            <span class="n">fill_opacity</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>  <span class="c1"># Transparency level of filled regions</span>
            <span class="n">line_opacity</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>  <span class="c1"># Transparency level of borders between regions</span>
            <span class="n">smooth_factor</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># Level of smoothing applied to the edges of regions</span>
            <span class="n">highlight</span><span class="o">=</span><span class="n">highlight</span><span class="p">,</span>  <span class="c1"># Enable or disable highlighting of regions on hover</span>
        <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>  <span class="c1"># Add the choropleth layer to the map</span>

        <span class="c1"># Add a tooltip to display the attribute values for each region when hovered over</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">GeoJsonTooltip</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">choropleth</span><span class="o">.</span><span class="n">geojson</span><span class="p">)</span>

        <span class="c1"># Add layer control to the map</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">LayerControl</span><span class="p">(</span><span class="n">collapsed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">karta</span><span class="p">)</span>

        <span class="c1"># Return the Folium map object containing the choropleth layer</span>
        <span class="k">return</span> <span class="n">karta</span></div>
</div>



<div class="viewcode-block" id="GeomUtils">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.GeomUtils">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GeomUtils</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class for performing various geometric operations on Shapely geometry objects.</span>

<span class="sd">    This class provides methods for determining UTM projections, transforming geometries between</span>
<span class="sd">    coordinate reference systems (CRS), calculating geometric statistics, and computing bearings</span>
<span class="sd">    for LineString geometries.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    find_proj(geom: Union[Point, LineString, Polygon, MultiPolygon]) -&gt; str</span>
<span class="sd">        Determines the appropriate UTM zone projection for a given geometry.</span>

<span class="sd">    trans_proj(geom: BaseGeometry, proj1: str, proj2: str) -&gt; BaseGeometry</span>
<span class="sd">        Transforms a Shapely geometry object from one CRS to another.</span>

<span class="sd">    geom_stats(geom: Optional[Union[Polygon, MultiPolygon]] = None, projection=None, unit: str = &quot;m&quot;) -&gt; Optional[List[Union[int, float]]]</span>
<span class="sd">        Computes geometric statistics for a Polygon or MultiPolygon geometry.</span>

<span class="sd">    bearing(geom: LineString) -&gt; tuple[int, int, str, str]</span>
<span class="sd">        Calculates the bearing and cardinal directions of a LineString.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This class relies on the `shapely`, `pyproj`, and `math` libraries for geometric operations.</span>
<span class="sd">    - Ensure that input geometries are valid Shapely objects and that CRS definitions are valid</span>
<span class="sd">      and supported by `pyproj`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shapely.geometry import Polygon, LineString</span>
<span class="sd">    &gt;&gt;&gt; geom_utils = GeomUtils()</span>

<span class="sd">    &gt;&gt;&gt; # Example for find_proj</span>
<span class="sd">    &gt;&gt;&gt; polygon = Polygon([(-120, 35), (-121, 35), (-121, 36), (-120, 36), (-120, 35)])</span>
<span class="sd">    &gt;&gt;&gt; utm_proj = geom_utils.find_proj(polygon)</span>
<span class="sd">    &gt;&gt;&gt; print(utm_proj)</span>
<span class="sd">    &#39;EPSG:32610&#39;</span>

<span class="sd">    &gt;&gt;&gt; # Example for trans_proj</span>
<span class="sd">    &gt;&gt;&gt; point = Point(10, 50)</span>
<span class="sd">    &gt;&gt;&gt; transformed_point = geom_utils.trans_proj(point, &quot;EPSG:4326&quot;, &quot;EPSG:32632&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(transformed_point)</span>
<span class="sd">    &lt;Point object at 0x...&gt;</span>

<span class="sd">    &gt;&gt;&gt; # Example for geom_stats</span>
<span class="sd">    &gt;&gt;&gt; stats = geom_utils.geom_stats(polygon, unit=&quot;km&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(stats)</span>
<span class="sd">    [1, 0, 4, 12322.539175581376, 444.0301771896464, &#39;EPSG:32631&#39;]</span>

<span class="sd">    &gt;&gt;&gt; # Example for bearing</span>
<span class="sd">    &gt;&gt;&gt; line = LineString([(0, 0), (1, 1)])</span>
<span class="sd">    &gt;&gt;&gt; bearing_info = geom_utils.bearing(line)</span>
<span class="sd">    &gt;&gt;&gt; print(bearing_info)</span>
<span class="sd">    (45, 45, &#39;NE&#39;, &#39;NE-SW&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GeomUtils.find_proj">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.GeomUtils.find_proj">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_proj</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the appropriate UTM zone projection for a given geometry.</span>

<span class="sd">        Calculates the Universal Transverse Mercator (UTM) zone projection based on the centroid</span>
<span class="sd">        coordinates of the input geometry. The function returns the corresponding EPSG code for</span>
<span class="sd">        the UTM zone in which the geometry is located.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geom : Point, LineString, Polygon, or MultiPolygon</span>
<span class="sd">            A Shapely geometry object, which can be a Point, Polygon, or MultiPolygon.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The EPSG code representing the UTM projection for the geometry&#39;s location. For the</span>
<span class="sd">            northern hemisphere, the function returns codes in the format &#39;EPSG:326XX&#39;. For the</span>
<span class="sd">            southern hemisphere, it returns &#39;EPSG:327XX&#39;, where &#39;XX&#39; is the UTM zone number.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The UTM (Universal Transverse Mercator) system divides the Earth into 60 longitudinal zones,</span>
<span class="sd">        each 6 degrees wide. This function uses the centroid of the input geometry to determine the</span>
<span class="sd">        appropriate zone and EPSG code.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; geom = Polygon([(-120, 35), (-121, 35), (-121, 36), (-120, 36), (-120, 35)])</span>
<span class="sd">        &gt;&gt;&gt; find_proj(geom)</span>
<span class="sd">        &#39;EPSG:32610&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">!=</span> <span class="s2">&quot;Point&quot;</span><span class="p">:</span>
            <span class="c1"># If the geometry is not a Point, use its centroid</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span>

        <span class="c1"># Extract latitude and longitude from the geometry</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">x</span>

        <span class="c1"># Determine the base EPSG code depending on the hemisphere</span>
        <span class="k">if</span> <span class="n">lat</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="s2">&quot;EPSG:326&quot;</span>  <span class="c1"># Northern Hemisphere</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="s2">&quot;EPSG:327&quot;</span>  <span class="c1"># Southern Hemisphere</span>

        <span class="c1"># Calculate the UTM zone number based on longitude</span>
        <span class="n">utm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">30</span> <span class="o">+</span> <span class="n">lon</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>

        <span class="c1"># Return the complete EPSG code for the UTM projection</span>
        <span class="k">return</span> <span class="n">proj</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">utm</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeomUtils.trans_proj">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.GeomUtils.trans_proj">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">trans_proj</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">BaseGeometry</span><span class="p">,</span> <span class="n">proj1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">proj2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseGeometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms a Shapely geometry object from one CRS to another.</span>

<span class="sd">        Uses `pyproj` to create a transformation pipeline that converts the input geometry</span>
<span class="sd">        from the source CRS (`proj1`) to the target CRS (`proj2`). The resulting geometry</span>
<span class="sd">        is returned in the new coordinate reference system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geom : BaseGeometry</span>
<span class="sd">            A Shapely geometry object to be transformed. This can include Point, Polygon,</span>
<span class="sd">            MultiPolygon, LineString, or any other Shapely geometry type.</span>
<span class="sd">        proj1 : str</span>
<span class="sd">            The EPSG code or PROJ string representing the source CRS of the input geometry.</span>
<span class="sd">        proj2 : str</span>
<span class="sd">            The EPSG code or PROJ string representing the target CRS for the transformed geometry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BaseGeometry</span>
<span class="sd">            The transformed Shapely geometry object in the target projection.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function requires `pyproj` and `shapely` libraries.</span>
<span class="sd">        - Ensure that the input and output CRS definitions are valid and supported by `pyproj`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">        &gt;&gt;&gt; geom = Point(10, 50)</span>
<span class="sd">        &gt;&gt;&gt; trans_proj(geom, &quot;EPSG:4326&quot;, &quot;EPSG:32632&quot;)</span>
<span class="sd">        &lt;Point object at 0x...&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a transformation function using pyproj&#39;s Transformer</span>
        <span class="n">project</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span><span class="n">pyproj</span><span class="o">.</span><span class="n">CRS</span><span class="p">(</span><span class="n">proj1</span><span class="p">),</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">CRS</span><span class="p">(</span><span class="n">proj2</span><span class="p">),</span> <span class="n">always_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span>

        <span class="c1"># Apply the transformation to the geometry and return the transformed geometry</span>
        <span class="k">return</span> <span class="n">transform</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeomUtils.geom_stats">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.GeomUtils.geom_stats">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geom_stats</span><span class="p">(</span>
        <span class="n">geom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;m&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes geometric statistics for a Polygon or MultiPolygon geometry.</span>

<span class="sd">        Calculates various statistics for a given Shapely geometry, such as the number of shells (outer boundaries),</span>
<span class="sd">        number of holes, number of shell points, total area, and total perimeter length. If no geometry is provided,</span>
<span class="sd">        the function will print a usage example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geom : Polygon or MultiPolygon, optional</span>
<span class="sd">            A Shapely geometry object (Polygon or MultiPolygon) for which to compute the statistics. If not provided,</span>
<span class="sd">            the function will print a usage example and not perform any computations. Default is None.</span>
<span class="sd">        projection: str, optional</span>
<span class="sd">            The EPSG code used for calculating perimeter and area of the geom in meters or kilometers, and square meters or square kilometers.</span>
<span class="sd">            If None, the UTM zone will be calculated.</span>
<span class="sd">        unit : str, optional</span>
<span class="sd">            The unit for area and length calculations. Accepts &quot;m&quot; for meters and &quot;km&quot; for kilometers. Default is &quot;m&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of int or float, optional</span>
<span class="sd">            A list containing the following statistics in order:</span>
<span class="sd">                - Number of shells (int)</span>
<span class="sd">                - Number of holes (int)</span>
<span class="sd">                - Number of shell points (int)</span>
<span class="sd">                - Total area (float)</span>
<span class="sd">                - Total perimeter length (float)</span>
<span class="sd">                - The projection used for calculating the area and perimeter</span>
<span class="sd">        If no geometry is provided, the function returns None.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; geom = Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])</span>
<span class="sd">        &gt;&gt;&gt; geom_stats(geom, unit=&quot;km&quot;)</span>
<span class="sd">        [1, 0, 4, 12322.539175581376, 444.0301771896464, &#39;EPSG:32631&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">geom</span><span class="p">:</span>  <span class="c1"># Print usage help if geom is None</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;mdf[[&#39;nshells&#39;, &#39;nholes&#39;, &#39;nshell_points&#39;, &#39;area&#39;, &#39;perimeter&#39;, &#39;projection&#39;]] = [gutils.geom_stats(geom, unit=&#39;km&#39;) for geom in mdf.geometry]&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Identify the appropriate UTM zone if the projection is not provided.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">projection</span><span class="p">:</span>
            <span class="n">projection</span> <span class="o">=</span> <span class="n">GeomUtils</span><span class="o">.</span><span class="n">find_proj</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="c1"># Handle different geometry types</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">:</span>
            <span class="n">polylist</span> <span class="o">=</span> <span class="p">[</span><span class="n">geom</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">geom</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">:</span>
            <span class="n">polylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input geometry must be a Polygon or MultiPolygon.&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize variables for calculating statistics</span>
        <span class="n">n_shells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polylist</span><span class="p">)</span>
        <span class="n">n_holes</span> <span class="o">=</span> <span class="n">n_shell_points</span> <span class="o">=</span> <span class="n">perimeter</span> <span class="o">=</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Iterate through each Polygon in the list to calculate statistics</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polylist</span><span class="p">:</span>
            <span class="n">n_holes</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">interiors</span><span class="p">)</span>  <span class="c1"># Count the number of holes</span>
            <span class="n">n_shell_points</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Count the number of shell points</span>
            <span class="c1"># Transform geometry to the appropriate projection and calculate length/area</span>
            <span class="n">perimeter</span> <span class="o">+=</span> <span class="n">GeomUtils</span><span class="o">.</span><span class="n">trans_proj</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">projection</span><span class="p">)</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">length</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="n">GeomUtils</span><span class="o">.</span><span class="n">trans_proj</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">projection</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>

        <span class="c1"># Return statistics based on the specified unit</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>  <span class="c1"># If unit is meters</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">n_shells</span><span class="p">,</span> <span class="n">n_holes</span><span class="p">,</span> <span class="n">n_shell_points</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">perimeter</span><span class="p">,</span> <span class="n">projection</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># If unit is kilometers</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">n_shells</span><span class="p">,</span> <span class="n">n_holes</span><span class="p">,</span> <span class="n">n_shell_points</span><span class="p">,</span> <span class="n">area</span> <span class="o">/</span> <span class="mi">1_000_000</span><span class="p">,</span> <span class="n">perimeter</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">projection</span><span class="p">]</span></div>


<div class="viewcode-block" id="GeomUtils.flatten_3d">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.GeomUtils.flatten_3d">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flatten_3d</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flattens a GeoSeries of 3D Polygons or MultiPolygons into 2D geometries.</span>

<span class="sd">        This function removes the z-coordinate from each 3D geometry in the input GeoSeries,</span>
<span class="sd">        converting it into a 2D Polygon or MultiPolygon. The result is a list of 2D geometries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geom : gpd.GeoSeries</span>
<span class="sd">            A GeoSeries containing 3D Polygons or MultiPolygons (geometries with z-coordinates).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Union[Polygon, MultiPolygon]]</span>
<span class="sd">            A list of 2D Polygons or MultiPolygons with the z-coordinates removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gdf.geometry = flatten_3d(gdf.geometry)</span>
<span class="sd">            Converts all 3D geometries in the GeoSeries `gdf.geometry` to 2D geometries.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The function is useful when working with datasets that contain 3D geometries but</span>
<span class="sd">        only 2D geometries are needed for further spatial analysis or visualization.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_geom</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">geom</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">has_z</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">:</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">xy</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)]</span>
                    <span class="n">new_p</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
                    <span class="n">new_geom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_p</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">:</span>
                    <span class="n">new_multi_p</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">xy</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ap</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)]</span>
                        <span class="n">new_p</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
                        <span class="n">new_multi_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_p</span><span class="p">)</span>
                    <span class="n">new_geom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MultiPolygon</span><span class="p">(</span><span class="n">new_multi_p</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_geom</span></div>


<div class="viewcode-block" id="GeomUtils.bearing">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.GeomUtils.bearing">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bearing</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">LineString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the bearing and cardinal directions of a LineString.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geom : shapely.geometry.LineString</span>
<span class="sd">            The input geometry for which the bearing is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[int, int, str, str]</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - `bearing` (int): The bearing angle in degrees (0 to 359).</span>
<span class="sd">            - `axis_bearing` (int): The axis bearing in degrees (0 to 179).</span>
<span class="sd">            - `cardinal_direction` (str): The cardinal direction (e.g., &quot;N&quot;, &quot;NE&quot;).</span>
<span class="sd">            - `axis_direction` (str): The cardinal axis direction (e.g., &quot;N-S&quot;, &quot;E-W&quot;).</span>
<span class="sd">            Returns (-1, -1, &quot;LOOP&quot;, &quot;LOOP&quot;) if the LineString forms a loop.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The bearing is calculated based on the angle between the starting and</span>
<span class="sd">        ending points of the LineString, relative to North.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import LineString</span>
<span class="sd">        &gt;&gt;&gt; geom = LineString([(0, 0), (1, 1)])</span>
<span class="sd">        &gt;&gt;&gt; bearing(geom)</span>
<span class="sd">        (45, 45, &#39;NE&#39;, &#39;NE-SW&#39;)</span>

<span class="sd">        &gt;&gt;&gt; loop_geom = LineString([(0, 0), (1, 1), (0, 0)])</span>
<span class="sd">        &gt;&gt;&gt; bearing(loop_geom)</span>
<span class="sd">        (-1, -1, &#39;LOOP&#39;, &#39;LOOP&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cardinal_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;NE&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;SE&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;SW&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;NW&quot;</span><span class="p">]</span>
        <span class="n">axis_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;N-S&quot;</span><span class="p">,</span> <span class="s2">&quot;NE-SW&quot;</span><span class="p">,</span> <span class="s2">&quot;E-W&quot;</span><span class="p">,</span> <span class="s2">&quot;NW-SE&quot;</span><span class="p">]</span>

        <span class="c1"># Check if the LineString is a loop</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;LOOP&quot;</span><span class="p">,</span> <span class="s2">&quot;LOOP&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">bearing</span> <span class="o">=</span> <span class="p">(</span><span class="mi">450</span> <span class="o">-</span> <span class="n">angle</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>  <span class="c1"># Angle between North and the road segment</span>

            <span class="n">ix</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">bearing</span> <span class="o">/</span> <span class="mi">45</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">bearing</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span><span class="p">,</span> <span class="n">cardinal_dirs</span><span class="p">[</span><span class="n">ix</span> <span class="o">%</span> <span class="mi">8</span><span class="p">],</span> <span class="n">axis_dirs</span><span class="p">[</span><span class="n">ix</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span></div>


<div class="viewcode-block" id="GeomUtils.line_to_points">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.GeomUtils.line_to_points">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">line_to_points</span><span class="p">(</span><span class="n">row</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits a LineString geometry into individual Point geometries while preserving original attributes.</span>

<span class="sd">        This function takes a GeoSeries representing a single row of a GeoDataFrame, extracts the coordinates</span>
<span class="sd">        from a LineString geometry, and creates a new GeoDataFrame with each Point as a separate row. All original</span>
<span class="sd">        attributes from the input row are preserved in the new GeoDataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row : gpd.GeoSeries</span>
<span class="sd">            A GeoSeries representing a single row of a GeoDataFrame. It must include a &#39;geometry&#39; column</span>
<span class="sd">            containing a LineString geometry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gpd.GeoDataFrame</span>
<span class="sd">            A new GeoDataFrame where each row corresponds to a Point geometry derived from the coordinates of the LineString.</span>
<span class="sd">            All other columns from the original row are preserved.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; line_gdf = gpd.GeoDataFrame({&quot;geometry&quot;: [LineString([(0, 0), (1, 1), (2, 2)])]})</span>
<span class="sd">        &gt;&gt;&gt; point_gdf = line_to_points(line_gdf.iloc[0])</span>
<span class="sd">        &gt;&gt;&gt; print(point_gdf)</span>
<span class="sd">           geometry</span>
<span class="sd">        0  POINT (0 0)</span>
<span class="sd">        1  POINT (1 1)</span>
<span class="sd">        2  POINT (2 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">)]</span>  <span class="c1"># create list of Point objects</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)),</span> <span class="n">columns</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span>  <span class="c1"># create new GeoDataFrame with all columns and Point geometry</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">gdf</span></div>
</div>



<div class="viewcode-block" id="CellUtils">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.CellUtils">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CellUtils</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class for performing operations on spatial cells, such as compaction, uncompaction, and statistical analysis.</span>
<span class="sd">    It supports various spatial indexing systems, including Geohash, H3, and S2, and provides methods to manipulate and</span>
<span class="sd">    analyze spatial cells efficiently.</span>

<span class="sd">    The class provides methods to:</span>
<span class="sd">    1. Compact spatial cells by merging adjacent cells into parent cells, reducing the total number of cells.</span>
<span class="sd">    2. Uncompact S2 cells by expanding them into their child cells at a specified resolution.</span>
<span class="sd">    3. Compute statistics for H3 cells covering a given geometry, including the number of cells and their area.</span>

<span class="sd">    Supported cell types:</span>
<span class="sd">    - Geohash: A hierarchical spatial indexing system using base-32 encoding.</span>
<span class="sd">    - H3: A hexagonal hierarchical spatial indexing system.</span>
<span class="sd">    - S2: A spherical geometry library for spatial indexing on a sphere.</span>

<span class="sd">    Key Features:</span>
<span class="sd">    - Compaction of spatial cells to reduce redundancy and improve efficiency.</span>
<span class="sd">    - Uncompaction of S2 cells for detailed spatial analysis.</span>
<span class="sd">    - Statistical analysis of H3 cells, including cell count and area calculations.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; cellop = CellOperation()</span>

<span class="sd">    &gt;&gt;&gt; # Compact H3 cells</span>
<span class="sd">    &gt;&gt;&gt; h3_cells = [&quot;8928308280fffff&quot;, &quot;8928308280bffff&quot;]</span>
<span class="sd">    &gt;&gt;&gt; compacted_cells = cellop.compact_cells(h3_cells, &quot;h3&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(compacted_cells)</span>

<span class="sd">    &gt;&gt;&gt; # Uncompact S2 cells</span>
<span class="sd">    &gt;&gt;&gt; s2_tokens = [&quot;89c2847c&quot;, &quot;89c2847d&quot;]</span>
<span class="sd">    &gt;&gt;&gt; uncompacted_cells = cellop.uncompact_s2(s2_tokens, level=10)</span>
<span class="sd">    &gt;&gt;&gt; print(uncompacted_cells)</span>

<span class="sd">    &gt;&gt;&gt; # Compute H3 cell statistics for a geometry</span>
<span class="sd">    &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">    &gt;&gt;&gt; geom = Polygon([(-122.0, 37.0), (-122.0, 38.0), (-121.0, 38.0), (-121.0, 37.0), (-122.0, 37.0)])</span>
<span class="sd">    &gt;&gt;&gt; cell_count, cell_area = cellop.h3_stats(geom, h3_res=9, compact=True)</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;Cell count: {cell_count}, Cell area: {cell_area} km^2&quot;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Compaction is useful for reducing the number of cells while maintaining spatial coverage.</span>
<span class="sd">    - Uncompaction allows for detailed analysis by expanding cells into finer resolutions.</span>
<span class="sd">    - H3 cell statistics are useful for understanding the spatial distribution and coverage of a geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CellUtils.compact_cells">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.CellUtils.compact_cells">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compact_cells</span><span class="p">(</span><span class="n">cells</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compacts a list of spatial cells (e.g., Geohash, S2, or H3) by merging adjacent cells into parent cells.</span>

<span class="sd">        The function takes a list of spatial cells and compacts them into larger cells if possible, reducing the total number</span>
<span class="sd">        of cells by merging adjacent cells into their parent cell at a coarser resolution. The compaction process differs based</span>
<span class="sd">        on the specified `cell_type` and its respective hierarchy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cells : list</span>
<span class="sd">            A list of spatial cells represented as strings. Each cell corresponds to a spatial area in a specific grid system</span>
<span class="sd">            (e.g., Geohash, H3, or S2).</span>

<span class="sd">        cell_type : str</span>
<span class="sd">            The type of spatial cell system used. Accepted values are:</span>
<span class="sd">            - &quot;geohash&quot; : Geohash spatial indexing system.</span>
<span class="sd">            - &quot;h3&quot;      : H3 hexagonal spatial indexing system.</span>
<span class="sd">            - &quot;s2&quot;      : S2 spherical spatial indexing system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of compacted spatial cells. Each cell is represented as a string and is at the coarsest resolution possible</span>
<span class="sd">            based on the input cells.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `cell_type` is not one of &quot;geohash&quot;, &quot;h3&quot;, or &quot;s2&quot;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For `h3`, the function uses the built-in `h3.compact()` method.</span>
<span class="sd">        - For `s2`, the compaction merges cells up to their parent cells by considering the S2 hierarchy.</span>
<span class="sd">        - For `geohash`, cells are merged based on shared prefixes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;h3&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">h3</span><span class="o">.</span><span class="n">compact_cells</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;s2&quot;</span><span class="p">:</span>
            <span class="c1"># Convert S2 cell IDs from tokens</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">s2</span><span class="o">.</span><span class="n">CellId</span><span class="o">.</span><span class="n">from_token</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">level</span><span class="p">()</span>  <span class="c1"># Assuming all S2 cells have the same resolution</span>
            <span class="n">num_children</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;geohash&quot;</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Resolution is based on the length of Geohash strings</span>
            <span class="n">num_children</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid cell_type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39;. Accepted values are: &#39;geohash&#39;, &#39;h3&#39;, &#39;s2&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize list to store compacted cells</span>
        <span class="n">compact_cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Get parent cell IDs based on the type</span>
            <span class="n">parent_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;s2&quot;</span> <span class="k">else</span> <span class="n">cell</span><span class="p">[:</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
            <span class="n">count_dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">parent_ids</span><span class="p">)</span>  <span class="c1"># Count occurrences of each parent cell</span>

            <span class="c1"># Get indices of parent cells with the required number of children</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parent_ids</span><span class="p">)</span> <span class="k">if</span> <span class="n">count_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_children</span><span class="p">]</span>

            <span class="c1"># Create a mask to exclude compacted cells</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="c1"># Append compacted cells to the result</span>
            <span class="n">compact_cells</span> <span class="o">+=</span> <span class="n">cells</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">parent_ids</span> <span class="k">if</span> <span class="n">count_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_children</span><span class="p">]))</span>

        <span class="c1"># Include any remaining cells in the compacted list</span>
        <span class="n">compact_cells</span> <span class="o">+=</span> <span class="n">cells</span>

        <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;geohash&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compact_cells</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Convert S2 cells back to tokens</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_token</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">compact_cells</span><span class="p">]</span></div>


<div class="viewcode-block" id="CellUtils.uncompact_s2">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.CellUtils.uncompact_s2">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">uncompact_s2</span><span class="p">(</span><span class="n">compact_tokens</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expands a list of compacted S2 cell tokens to a specified resolution level.</span>

<span class="sd">        This function takes a list of compact S2 cell tokens and generates their child cells up to the desired</span>
<span class="sd">        resolution level. It is used to &quot;uncompact&quot; S2 cells that have been previously compacted, producing a</span>
<span class="sd">        more detailed representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compact_tokens : list</span>
<span class="sd">            A list of S2 cell tokens represented as strings. These tokens are at a coarser resolution level and</span>
<span class="sd">            will be expanded into their child cells.</span>

<span class="sd">        level : int</span>
<span class="sd">            The target S2 cell resolution level to which the input tokens should be expanded. The resolution level</span>
<span class="sd">            determines the size of the child cells. A higher level corresponds to finer granularity (smaller cells).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of S2 cell tokens represented as strings. Each token corresponds to a child cell of the input</span>
<span class="sd">            compact tokens, expanded to the specified resolution level.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the provided `level` is less than or equal to the resolution level of the input `compact_tokens`.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; compact_tokens = [&quot;89c2847c&quot;, &quot;89c2847d&quot;]</span>
<span class="sd">        &gt;&gt;&gt; uncompact_s2(compact_tokens, level=10)</span>
<span class="sd">        [&quot;89c2847c1&quot;, &quot;89c2847c2&quot;, &quot;89c2847c3&quot;, ..., &quot;89c2847d1&quot;, &quot;89c2847d2&quot;, ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uncompact_tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">compact_tokens</span><span class="p">:</span>
            <span class="n">cell_id</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">CellId</span><span class="o">.</span><span class="n">from_token</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>  <span class="c1"># Convert each token to an S2 CellId object</span>
            <span class="n">uncompact_tokens</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cell_id</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>  <span class="c1"># Generate child cells at the specified level</span>
        <span class="c1"># Convert each CellId object back to a token and remove duplicates</span>
        <span class="n">uncompact_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">to_token</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">uncompact_tokens</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">uncompact_tokens</span><span class="p">))</span></div>


<div class="viewcode-block" id="CellUtils.h3_stats">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.CellUtils.h3_stats">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">h3_stats</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">BaseGeometry</span><span class="p">,</span> <span class="n">h3_res</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">compact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes H3 cell statistics for a given geometry at a specified resolution.</span>

<span class="sd">        This function takes a Shapely geometry object and computes the number of H3 cells covering the geometry at a</span>
<span class="sd">        specified resolution. It also calculates the area of each H3 cell at the given resolution. Optionally, the function</span>
<span class="sd">        can return the compacted set of H3 cells, reducing the number of cells required to represent the geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geom : shapely.geometry.base.BaseGeometry</span>
<span class="sd">            A Shapely geometry object (e.g., Polygon or MultiPolygon) representing the area of interest.</span>
<span class="sd">        h3_res : int</span>
<span class="sd">            The H3 resolution level for generating spatial cells. The resolution level controls the granularity of the cells.</span>
<span class="sd">        compact : bool, optional</span>
<span class="sd">            If True, the function returns a compacted set of H3 cells, reducing the number of cells needed to represent the geometry.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - int: Number of H3 cells covering the given geometry.</span>
<span class="sd">            - float: Area of each H3 cell at the specified resolution, in square kilometers.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; geom = Polygon([(-122.0, 37.0), (-122.0, 38.0), (-121.0, 38.0), (-121.0, 37.0), (-122.0, 37.0)])</span>
<span class="sd">        &gt;&gt;&gt; h3_stats(geom, h3_res=9, compact=True)</span>
<span class="sd">        (512, 0.001)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The function utilizes the H3 library for generating and compacting H3 cells and for calculating cell area. The area</span>
<span class="sd">        is always returned in square kilometers (&quot;km^2&quot;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">SpatialIndex</span><span class="o">.</span><span class="n">poly_cell</span><span class="p">([</span><span class="n">geom</span><span class="p">],</span> <span class="n">cell_type</span><span class="o">=</span><span class="s2">&quot;h3&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">h3_res</span><span class="p">)</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">h3</span><span class="o">.</span><span class="n">hex_area</span><span class="p">(</span><span class="n">h3_res</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;km^2&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compact</span><span class="p">:</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="n">h3</span><span class="o">.</span><span class="n">compact</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">),</span> <span class="n">area</span></div>
</div>



<div class="viewcode-block" id="OSMUtils">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.OSMUtils">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OSMUtils</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class for converting OpenStreetMap (OSM) way IDs into Shapely geometries.</span>

<span class="sd">    This class provides methods to retrieve and convert OSM way IDs into Shapely `Polygon`</span>
<span class="sd">    or `LineString` objects using the Overpass API. It supports both single and multiple</span>
<span class="sd">    way ID conversions.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    way_to_geom(way_id: int) -&gt; Optional[LineString or Polygon]</span>
<span class="sd">        Converts a single OSM way ID into a Shapely `Polygon` or `LineString` object.</span>

<span class="sd">    ways_to_geom(ids: List[int]) -&gt; List[LineString or Polygon]</span>
<span class="sd">        Converts a list of OSM way IDs into a list of Shapely `Polygon` or `LineString` objects.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The class uses the Overpass API to fetch geometry data for OSM ways.</span>
<span class="sd">    - Ensure that the provided way IDs are valid and that the Overpass API is accessible.</span>
<span class="sd">    - The returned geometries are in WGS84 (latitude/longitude) coordinates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; converter = WayConverter()</span>
<span class="sd">    &gt;&gt;&gt; # Convert a single way ID</span>
<span class="sd">    &gt;&gt;&gt; geometry = converter.way_to_geom(123456)</span>
<span class="sd">    &gt;&gt;&gt; print(geometry)</span>
<span class="sd">    POLYGON ((13.3888 52.5170, 13.3976 52.5291, 13.4286 52.5232, 13.3888 52.5170))</span>

<span class="sd">    &gt;&gt;&gt; # Convert multiple way IDs</span>
<span class="sd">    &gt;&gt;&gt; geometries = converter.ways_to_geom([123456, 234567])</span>
<span class="sd">    &gt;&gt;&gt; print(geometries)</span>
<span class="sd">    [&lt;shapely.geometry.polygon.Polygon object at 0x...&gt;,</span>
<span class="sd">     &lt;shapely.geometry.linestring.LineString object at 0x...&gt;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OSMUtils.way_to_geom">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.OSMUtils.way_to_geom">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">way_to_geom</span><span class="p">(</span><span class="n">way_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;https://overpass-api.de/api/interpreter&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LineString</span> <span class="ow">or</span> <span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an OSM way ID into a Shapely Polygon or LineString object.</span>

<span class="sd">        This function retrieves the geometry corresponding to the given OSM way ID and</span>
<span class="sd">        returns it as a Shapely `Polygon` or `LineString` object based on whether the way</span>
<span class="sd">        forms a closed loop or not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        way_id : int</span>
<span class="sd">            The OpenStreetMap (OSM) way ID to be retrieved.</span>
<span class="sd">        url : str, optional</span>
<span class="sd">            The URL endpoint for the Overpass API. Defaults to &quot;https://overpass-api.de/api/interpreter&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shapely.geometry.Polygon or shapely.geometry.LineString</span>
<span class="sd">            A Shapely `Polygon` object if the way forms a closed loop, or a `LineString`</span>
<span class="sd">            object otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function constructs an Overpass API query using the given way ID,</span>
<span class="sd">          requests the geometry, and then converts it into a Shapely geometry.</span>
<span class="sd">        - Assumes that the Overpass API returns data in JSON format with a &quot;geometry&quot; attribute.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; way_id = 123456</span>
<span class="sd">        &gt;&gt;&gt; url = &quot;https://overpass-api.de/api/interpreter&quot;</span>
<span class="sd">        &gt;&gt;&gt; geometry = way_to_geom(way_id, url)</span>
<span class="sd">        &gt;&gt;&gt; print(geometry)</span>
<span class="sd">        POLYGON ((13.3888 52.5170, 13.3976 52.5291, 13.4286 52.5232, 13.3888 52.5170))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[out:json][timeout:600][maxsize:4073741824];way(</span><span class="si">{</span><span class="n">way_id</span><span class="si">}</span><span class="s2">);out geom;&quot;</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">query</span><span class="p">})</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="p">[</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">response</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">geom</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">geom</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># Check if the way forms a closed loop</span>
            <span class="k">return</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LineString</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span></div>


<div class="viewcode-block" id="OSMUtils.ways_to_geom">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.OSMUtils.ways_to_geom">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ways_to_geom</span><span class="p">(</span><span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;https://overpass-api.de/api/interpreter&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">LineString</span> <span class="ow">or</span> <span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an array of OpenStreetMap (OSM) way IDs into Shapely geometries.</span>

<span class="sd">        This function retrieves the geometries corresponding to the given OSM way IDs and</span>
<span class="sd">        returns a list of Shapely `LineString` or `Polygon` objects based on the geometries</span>
<span class="sd">        fetched from the OSM API.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ids : list of int</span>
<span class="sd">            A list of OSM way IDs to be retrieved.</span>
<span class="sd">        url : str, optional</span>
<span class="sd">            The URL endpoint for the Overpass API. Defaults to &quot;https://overpass-api.de/api/interpreter&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of shapely.geometry.LineString or shapely.geometry.Polygon</span>
<span class="sd">            A list of Shapely `LineString` or `Polygon` objects representing the geometries</span>
<span class="sd">            of the OSM ways. If the way forms a closed loop, it is returned as a `Polygon`;</span>
<span class="sd">            otherwise, it is returned as a `LineString`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function constructs an Overpass API query using the given IDs, requests the</span>
<span class="sd">          geometries, and then converts them into Shapely geometries.</span>
<span class="sd">        - The function assumes that the Overpass API returns data in JSON format and expects</span>
<span class="sd">          the &quot;geometry&quot; attribute to contain the coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; way_ids = [123456, 234567, 345678]</span>
<span class="sd">        &gt;&gt;&gt; url = &quot;https://overpass-api.de/api/interpreter&quot;</span>
<span class="sd">        &gt;&gt;&gt; geometries = ways_to_geom(way_ids, url)</span>
<span class="sd">        &gt;&gt;&gt; print(geometries)</span>
<span class="sd">        [&lt;shapely.geometry.polygon.Polygon object at 0x...&gt;,</span>
<span class="sd">         &lt;shapely.geometry.linestring.LineString object at 0x...&gt;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;[out:json][timeout:600][maxsize:4073741824];&quot;</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;way(</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">);out geom;&quot;</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">query</span><span class="p">})</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="p">[</span><span class="s2">&quot;elements&quot;</span><span class="p">]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">response</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>  <span class="c1"># used later to determine if the way is a Polygon or a LineString</span>
        <span class="n">ways</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">response</span><span class="p">]</span>

        <span class="n">geoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">way</span> <span class="ow">in</span> <span class="n">ways</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">way</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># in polygons the first and last items are the same</span>
                <span class="n">geoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">geoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LineString</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">geoms</span></div>


<div class="viewcode-block" id="OSMUtils.decode">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.OSMUtils.decode">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decodes an encoded polyline string from Valhalla into a list of coordinates.</span>

<span class="sd">        Valhalla routing, map-matching, and elevation services use an encoded polyline format</span>
<span class="sd">        to store a series of latitude and longitude coordinates as a single string. This function</span>
<span class="sd">        decodes the polyline into a list of coordinates with six decimal precision.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        encoded : str</span>
<span class="sd">            An encoded polyline string as per the Valhalla encoding format.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of list of float</span>
<span class="sd">            A list of [longitude, latitude] pairs decoded from the input polyline string.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function uses six decimal degrees of precision for decoding Valhalla&#39;s encoded polylines.</span>
<span class="sd">        - The decoded coordinates are returned in [longitude, latitude] format.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://github.com/valhalla/valhalla-docs/blob/master/decoding.md#decode-a-route-shape</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; encoded_polyline = &quot;_p~iF~ps|U_ulLnnqC_mqNvxq`@&quot;</span>
<span class="sd">        &gt;&gt;&gt; decoded_coords = decode(encoded_polyline)</span>
<span class="sd">        &gt;&gt;&gt; print(decoded_coords)</span>
<span class="sd">        [[-120.2, 38.5], [-120.95, 40.7], [-126.453, 43.252]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">1e6</span>  <span class="c1"># Six decimal places of precision in Valhalla</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">):</span>  <span class="c1"># For each byte in the encoded string</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># To store latitude and longitude</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">byte</span> <span class="o">=</span> <span class="mh">0x20</span>
                <span class="k">while</span> <span class="n">byte</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">:</span>  <span class="c1"># Keep decoding bytes until the complete coordinate is read</span>
                    <span class="n">byte</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">encoded</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">63</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">ll</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span>
                    <span class="n">shift</span> <span class="o">+=</span> <span class="mi">5</span>
                <span class="n">ll</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">ll</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">ll</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="n">ll</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">previous</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ll</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="c1"># Convert to float and format the result</span>
            <span class="n">decoded</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.6f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ll</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.6f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">decoded</span></div>


<div class="viewcode-block" id="OSMUtils.map_matching">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.OSMUtils.map_matching">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_matching</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;osrm&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs map matching using Valhalla&#39;s Meili service.</span>

<span class="sd">        Map matching aligns a series of GPS points onto a road network. This function takes a DataFrame</span>
<span class="sd">        of coordinates, sends a request to the Meili map-matching service, and returns the matched</span>
<span class="sd">        coordinates along with other route information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pd.DataFrame</span>
<span class="sd">            A pandas DataFrame containing the GPS coordinates to be map-matched. It should be in the</span>
<span class="sd">            format of [{&quot;lon&quot;: float, &quot;lat&quot;: float}, ...].</span>
<span class="sd">        cost : str</span>
<span class="sd">            The routing profile to use for map matching. Common values include &quot;auto&quot;, &quot;bicycle&quot;,</span>
<span class="sd">            or &quot;pedestrian&quot;.</span>
<span class="sd">        url : str</span>
<span class="sd">            The URL endpoint for the Meili map-matching service.</span>
<span class="sd">        format : str, optional</span>
<span class="sd">            The response format for the request, either &quot;osrm&quot; or &quot;geojson&quot;. Defaults to &quot;osrm&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[dict]</span>
<span class="sd">            A dictionary representing the JSON response from the map-matching service if the request</span>
<span class="sd">            is successful, otherwise None.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; coordinates = [{&quot;lon&quot;: -73.9857, &quot;lat&quot;: 40.7484}, {&quot;lon&quot;: -73.9851, &quot;lat&quot;: 40.7478}]</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(coordinates)</span>
<span class="sd">        &gt;&gt;&gt; url = &quot;https://valhalla.mapzen.com/trace_attributes&quot;</span>
<span class="sd">        &gt;&gt;&gt; matched_route = map_matching(df, &quot;auto&quot;, url)</span>
<span class="sd">        &gt;&gt;&gt; print(matched_route)</span>
<span class="sd">        {&#39;shape&#39;: &#39;_p~iF~ps|U_ulLnnqC_mqNvxq`@&#39;, &#39;confidence_score&#39;: 1.0}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meili_head</span> <span class="o">=</span> <span class="s1">&#39;{&quot;shape&quot;:&#39;</span>  <span class="c1"># Initial portion of the request body</span>
        <span class="n">meili_coordinates</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;records&quot;</span><span class="p">)</span>  <span class="c1"># Convert DataFrame to JSON format</span>

        <span class="n">meili_tail</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;, &quot;search_radius&quot;:150, &quot;shape_match&quot;:&quot;map_snap&quot;, &quot;costing&quot;:&quot;</span><span class="si">{</span><span class="n">cost</span><span class="si">}</span><span class="s1">&quot;, &quot;format&quot;:&quot;</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s1">&quot;</span><span class="se">}}</span><span class="s1">&#39;</span>

        <span class="c1"># Combine the header, coordinates, and tail into a single request body</span>
        <span class="n">meili_request_body</span> <span class="o">=</span> <span class="n">meili_head</span> <span class="o">+</span> <span class="n">meili_coordinates</span> <span class="o">+</span> <span class="n">meili_tail</span>

        <span class="c1"># Send the request to the Meili service</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">meili_request_body</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Content-type&quot;</span><span class="p">:</span> <span class="s2">&quot;application/json&quot;</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>  <span class="c1"># Convert the JSON response to a dictionary</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="SpatialIndex">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SpatialIndex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for performing spatial indexing operations on geographic data.</span>

<span class="sd">    This class provides methods to convert geographic coordinates (latitude, longitude) and geometries</span>
<span class="sd">    (Polygon, MultiPolygon) into spatial cell representations using various encoding systems such as</span>
<span class="sd">    Geohash, S2, and H3. It also supports parallel processing for efficient handling of large datasets.</span>

<span class="sd">    Methods:</span>
<span class="sd">    --------</span>
<span class="sd">    point_cell(lats, lons, cell_type, res):</span>
<span class="sd">        Converts latitude and longitude coordinates into spatial index representations.</span>

<span class="sd">    poly_cell(geoms, cell_type, res, dump):</span>
<span class="sd">        Converts a list of geometries into a set of unique spatial cells.</span>

<span class="sd">    ppoint_cell(lats, lons, cell_type, res):</span>
<span class="sd">        Converts latitude and longitude coordinates into spatial index representations in parallel.</span>

<span class="sd">    ppoly_cell(mdf, cell_type, res, compact, dump, verbose):</span>
<span class="sd">        Performs parallelized conversion of geometries in a GeoDataFrame to cell identifiers.</span>

<span class="sd">    cell_point(cells, cell_type):</span>
<span class="sd">        Converts a list of cell IDs into their corresponding centroids.</span>

<span class="sd">    cell_poly(cells, cell_type):</span>
<span class="sd">        Converts a list of spatial cells to their corresponding geometries and resolution levels.</span>

<span class="sd">    pcell_point(cells, cell_type):</span>
<span class="sd">        Converts a list of cell IDs into their corresponding latitude and longitude points in parallel.</span>

<span class="sd">    pcell_poly(cells, cell_type):</span>
<span class="sd">        Parallelized version of `cell_poly`, converting a list of spatial cells to geometries and resolution levels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpatialIndex.point_cell">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex.point_cell">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">point_cell</span><span class="p">(</span><span class="n">lats</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">lons</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert latitude and longitude coordinates into spatial index representations using various cell encoding types.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        lats : list[float]</span>
<span class="sd">            A list of latitude values (in decimal degrees) for each point to encode.</span>
<span class="sd">        lons : list[float]</span>
<span class="sd">            A list of longitude values (in decimal degrees) for each point to encode.</span>
<span class="sd">        cell_type : str</span>
<span class="sd">            The type of spatial encoding to use. Options are:</span>
<span class="sd">                - &#39;geohash&#39;: Encodes the coordinates using the geohash format.</span>
<span class="sd">                - &#39;s2&#39;: Encodes the coordinates using the S2 library, outputting a string representation.</span>
<span class="sd">                - &#39;s2_int&#39;: Encodes the coordinates using the S2 library, outputting an integer representation.</span>
<span class="sd">                - &#39;h3&#39;: Encodes the coordinates using the H3 library, outputting a hex string.</span>
<span class="sd">        res : int</span>
<span class="sd">            The resolution or precision level for the encoding, specific to each encoding type.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        list</span>
<span class="sd">            A list of encoded cell identifiers. The data type of each identifier depends on `cell_type`:</span>
<span class="sd">                - &#39;geohash&#39; and &#39;s2&#39;: list of str</span>
<span class="sd">                - &#39;s2_int&#39;: list of int</span>
<span class="sd">                - &#39;h3&#39;: list of str</span>

<span class="sd">        Raises:</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `cell_type` is not one of &#39;geohash&#39;, &#39;s2&#39;, &#39;s2_int&#39;, or &#39;h3&#39;.</span>

<span class="sd">        Example:</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; lats = [37.7749, 34.0522]</span>
<span class="sd">        &gt;&gt;&gt; lons = [-122.4194, -118.2437]</span>
<span class="sd">        &gt;&gt;&gt; point_cell(lats, lons, &quot;geohash&quot;, 6)</span>
<span class="sd">        [&#39;9q8yy&#39;, &#39;9qh0b&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;geohash&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">pygeohash</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;s2&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">s2</span><span class="o">.</span><span class="n">geo_to_s2</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)]</span>  <span class="c1"># string</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;s2_int&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">geo_to_s2</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">res</span><span class="p">),</span> <span class="mi">16</span><span class="p">)</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)]</span>  <span class="c1"># int data type requires less memory</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;h3&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">h3</span><span class="o">.</span><span class="n">latlng_to_cell</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported cell type: </span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">. Choose &#39;geohash&#39;, &#39;s2&#39;, &#39;s2_int&#39;, or &#39;h3&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpatialIndex.poly_cell">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex.poly_cell">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">poly_cell</span><span class="p">(</span>
        <span class="n">geoms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]],</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dump</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a list of geometries into a set of unique spatial cells based on the specified cell type and resolution.</span>

<span class="sd">        This function takes a list of Shapely geometries (e.g., Polygon, MultiPolygon) and converts them into spatial cells</span>
<span class="sd">        using one of the supported cell systems: Geohash, S2, or H3. The resulting cells are returned as a list of unique</span>
<span class="sd">        cell IDs. If `dump` is set to a valid directory path, the cells are saved to a file in that directory, instead of being returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geoms : list of shapely.geometry.Polygon or shapely.geometry.MultiPolygon</span>
<span class="sd">            A list of Shapely geometry objects (Polygon or MultiPolygon).</span>
<span class="sd">        cell_type : str</span>
<span class="sd">            The type of spatial cell system to use. Supported values are &quot;geohash&quot;, &quot;s2&quot;, or &quot;h3&quot;.</span>
<span class="sd">        res : int</span>
<span class="sd">            The resolution level for the spatial cells. The resolution parameter determines the granularity of the cells.</span>
<span class="sd">        dump : str, optional</span>
<span class="sd">            If set to a valid directory path (string), the cells are saved to a file in the specified folder.</span>
<span class="sd">            The file will be saved in a subdirectory structure following the pattern: `/path/to/dir/cell_type/res/`.</span>
<span class="sd">            If `dump` is None, the function returns the list of cell IDs. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str or None</span>
<span class="sd">            If `dump` is None, a list of unique cell IDs is returned.</span>
<span class="sd">            If `dump` is provided, None is returned after saving the cells to a file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `cell_type` is not one of the supported values (&quot;geohash&quot;, &quot;s2&quot;, &quot;h3&quot;).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, MultiPolygon</span>
<span class="sd">        &gt;&gt;&gt; geometries = [Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]), MultiPolygon([...])]</span>
<span class="sd">        &gt;&gt;&gt; # Convert geometries to H3 cells at resolution 9</span>
<span class="sd">        &gt;&gt;&gt; h3_cells = poly_cell(geometries, cell_type=&quot;h3&quot;, res=9)</span>

<span class="sd">        &gt;&gt;&gt; # Convert geometries to S2 cells and save to a directory</span>
<span class="sd">        &gt;&gt;&gt; poly_cell(geometries, cell_type=&quot;s2&quot;, res=10, dump=&quot;~/Desktop/spatial_cells&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">geoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">:</span>
                <span class="n">polys</span> <span class="o">+=</span> <span class="p">[</span><span class="n">geom</span><span class="o">.</span><span class="n">__geo_interface__</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">geom</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">:</span>  <span class="c1"># If MultiPolygon, extract each Polygon separately</span>
                <span class="n">polys</span> <span class="o">+=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">__geo_interface__</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;geohash&quot;</span><span class="p">:</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">geohash</span> <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">geoms</span> <span class="k">for</span> <span class="n">geohash</span> <span class="ow">in</span> <span class="n">polygon_to_geohashes</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">inner</span><span class="o">=</span><span class="kc">False</span><span class="p">)})</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;s2&quot;</span><span class="p">:</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="p">{</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">s2</span><span class="o">.</span><span class="n">polyfill</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">geo_json_conformant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_id</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;h3&quot;</span><span class="p">:</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">h3</span><span class="o">.</span><span class="n">geo_to_cells</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">res</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported cell type: </span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">. Choose &#39;geohash&#39;, &#39;s2&#39;, or &#39;h3&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dump</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cells</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create the directories if they don&#39;t exist</span>
            <span class="n">cells_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dump</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cells_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cells_path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="s2">.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">json_file</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="SpatialIndex.ppoint_cell">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex.ppoint_cell">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ppoint_cell</span><span class="p">(</span><span class="n">lats</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">lons</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts lists of latitude and longitude points to cell identifiers in parallel.</span>

<span class="sd">        This function takes lists of latitude and longitude points and converts each pair</span>
<span class="sd">        into a cell identifier based on the specified `cell_type` and resolution `res`.</span>
<span class="sd">        It leverages parallel processing to speed up the conversion, dividing the data</span>
<span class="sd">        into chunks and using `Pool.starmap` for concurrent execution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lats : list of float</span>
<span class="sd">            List of latitude values.</span>
<span class="sd">        lons : list of float</span>
<span class="sd">            List of longitude values, corresponding element-wise to the latitude list.</span>
<span class="sd">        cell_type : str</span>
<span class="sd">            The type of spatial encoding to use. Options are:</span>
<span class="sd">                - &#39;geohash&#39;: Encodes the coordinates using the geohash format.</span>
<span class="sd">                - &#39;s2&#39;: Encodes the coordinates using the S2 library, outputting a string representation.</span>
<span class="sd">                - &#39;s2_int&#39;: Encodes the coordinates using the S2 library, outputting an integer representation.</span>
<span class="sd">                - &#39;h3&#39;: Encodes the coordinates using the H3 library, outputting a hex string.</span>
<span class="sd">        res : int</span>
<span class="sd">            Resolution or precision level for the cell identifiers. Higher values indicate finer precision.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of cell identifiers corresponding to the input latitude and longitude points.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `cell_type` is not one of &#39;geohash&#39;, &#39;s2&#39;, &#39;s2_int&#39;, or &#39;h3&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function splits the input latitude and longitude lists into chunks and performs the cell</span>
<span class="sd">        conversion in parallel, with each chunk processed by a separate CPU core. This can significantly</span>
<span class="sd">        reduce processing time for large datasets.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; lats = [37.7749, 40.7128]</span>
<span class="sd">        &gt;&gt;&gt; lons = [-122.4194, -74.0060]</span>
<span class="sd">        &gt;&gt;&gt; cell_type = &quot;h3&quot;</span>
<span class="sd">        &gt;&gt;&gt; res = 9</span>
<span class="sd">        &gt;&gt;&gt; ppoint_cell(lats, lons, cell_type, res)</span>
<span class="sd">        [&#39;8928308280fffff&#39;, &#39;8a28308280fffff&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_cores</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>

        <span class="c1"># Prepare arguments for parallel processing</span>
        <span class="n">lat_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>
        <span class="n">lon_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lat_chunks</span><span class="p">,</span> <span class="n">lon_chunks</span><span class="p">,</span> <span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">,</span> <span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>

        <span class="c1"># Parallelize the conversion using Pool.starmap</span>
        <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">n_cores</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">SpatialIndex</span><span class="o">.</span><span class="n">point_cell</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">cells</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>  <span class="c1"># Flatten the list of cells</span>

        <span class="k">return</span> <span class="n">cells</span></div>


<div class="viewcode-block" id="SpatialIndex.ppoly_cell">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex.ppoly_cell">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ppoly_cell</span><span class="p">(</span>
        <span class="n">mdf</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">compact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dump</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a parallelised conversion of geometries in a GeoDataFrame to cell identifiers of a specified type</span>
<span class="sd">        (e.g., Geohash, S2, or H3), optionally compacting the result to reduce the number of cells.</span>

<span class="sd">        This function first divides the bounding box of the input GeoDataFrame into smaller grid cells, then calculates</span>
<span class="sd">        the intersection between these grid cells and the input geometries. The resulting geometries are processed in</span>
<span class="sd">        parallel to generate cell identifiers according to the specified `cell_type` and `res` (resolution). The result</span>
<span class="sd">        can be compacted to reduce the number of cells. Optionally, if `dump` is provided, the results are saved in multiple</span>
<span class="sd">        files, where the number of files is 4 times the number of CPU cores available in the system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mdf : gpd.GeoDataFrame</span>
<span class="sd">            A GeoDataFrame containing geometries that need to be converted to cell identifiers.</span>

<span class="sd">        cell_type : str</span>
<span class="sd">            The type of cell identifier to use. Options are:</span>
<span class="sd">            - &quot;geohash&quot;: Converts geometries to Geohash identifiers.</span>
<span class="sd">            - &quot;s2&quot;: Converts geometries to S2 cell tokens.</span>
<span class="sd">            - &quot;h3&quot;: Converts geometries to H3 cell tokens.</span>

<span class="sd">        res : int</span>
<span class="sd">            The resolution or precision level of the cell identifiers. Higher values indicate finer precision.</span>

<span class="sd">        compact : bool, optional, default=False</span>
<span class="sd">            If True, compact the resulting cells to reduce their number. This is typically applicable for S2 and H3 cells.</span>

<span class="sd">        dump : str, optional</span>
<span class="sd">            A string representing a valid directory path. If provided, the cells are saved in multiple files</span>
<span class="sd">            within the directory `/path/to/dir/cell_type/res/`. The number of output files will be 4 times the number</span>
<span class="sd">            of CPU cores available in the system. If not provided, the function returns the list of cell identifiers</span>
<span class="sd">            instead of saving them to files. Default is None.</span>

<span class="sd">        verbose : bool, optional, default=False</span>
<span class="sd">            If True, print timing and progress information to the console.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[List[str], int]</span>
<span class="sd">            - A list of cell identifiers as strings, corresponding to the geometries in the input GeoDataFrame.</span>
<span class="sd">            - The total number of unique cell identifiers.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid `cell_type` is provided. Supported types are &quot;geohash&quot;, &quot;s2&quot;, and &quot;h3&quot;.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; # Assuming `mdf` is a GeoDataFrame with geometries:</span>
<span class="sd">        &gt;&gt;&gt; cells, count = ppoly_cell(mdf, cell_type=&quot;s2&quot;, res=10, compact=True, dump=&quot;~/Desktop/cells&quot;, verbose=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Generated {count} cells: {cells}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Slicing the bounding box of polygons ... &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="c1"># Determine the number of slices and grid cells based on CPU cores</span>
        <span class="n">n_cores</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="n">n_cores</span>

        <span class="c1"># Calculate the bounding box dimensions</span>
        <span class="n">minlon</span><span class="p">,</span> <span class="n">minlat</span><span class="p">,</span> <span class="n">maxlon</span><span class="p">,</span> <span class="n">maxlat</span> <span class="o">=</span> <span class="n">mdf</span><span class="o">.</span><span class="n">total_bounds</span>
        <span class="n">dlon</span> <span class="o">=</span> <span class="n">maxlon</span> <span class="o">-</span> <span class="n">minlon</span>
        <span class="n">dlat</span> <span class="o">=</span> <span class="n">maxlat</span> <span class="o">-</span> <span class="n">minlat</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">dlon</span> <span class="o">/</span> <span class="n">dlat</span>

        <span class="c1"># Calculate the number of grid cells in x and y directions</span>
        <span class="n">x_cells</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span>
        <span class="n">y_cells</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">/</span> <span class="n">ratio</span><span class="p">)</span>

        <span class="c1"># Calculate step size for grid cells</span>
        <span class="n">steplon</span> <span class="o">=</span> <span class="n">dlon</span> <span class="o">/</span> <span class="n">x_cells</span>
        <span class="n">steplat</span> <span class="o">=</span> <span class="n">dlat</span> <span class="o">/</span> <span class="n">y_cells</span>

        <span class="c1"># Create grid polygons based on bounding box slices</span>
        <span class="n">grid_polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minlat</span><span class="p">,</span> <span class="n">maxlat</span><span class="p">,</span> <span class="n">steplat</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">lon</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minlon</span><span class="p">,</span> <span class="n">maxlon</span><span class="p">,</span> <span class="n">steplon</span><span class="p">):</span>
                <span class="n">llon</span><span class="p">,</span> <span class="n">llat</span><span class="p">,</span> <span class="n">ulon</span><span class="p">,</span> <span class="n">ulat</span> <span class="o">=</span> <span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">+</span> <span class="n">steplon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">+</span> <span class="n">steplat</span><span class="p">)</span>  <span class="c1"># lower lat, upper lat</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">llon</span><span class="p">,</span> <span class="n">llat</span><span class="p">),</span> <span class="p">(</span><span class="n">ulon</span><span class="p">,</span> <span class="n">llat</span><span class="p">),</span> <span class="p">(</span><span class="n">ulon</span><span class="p">,</span> <span class="n">ulat</span><span class="p">),</span> <span class="p">(</span><span class="n">llon</span><span class="p">,</span> <span class="n">ulat</span><span class="p">)])</span>
                <span class="n">grid_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

        <span class="n">gmdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">grid_polygons</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">mdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>  <span class="c1"># Create a GeoDataFrame with grid polygons</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">elapsed_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">}</span><span class="s2"> seconds.   </span><span class="si">{</span><span class="n">slices</span><span class="si">}</span><span class="s2"> slices created.&quot;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Performing intersection between grid and polygons ... &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="c1"># Perform intersection between input geometries and grid cells</span>
        <span class="n">gmdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">mdf</span><span class="p">,</span> <span class="n">gmdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">)</span>  <span class="c1"># grid mdf</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">elapsed_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">}</span><span class="s2"> seconds.   </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gmdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> intersected slices.&quot;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating cell IDs in parallel ... &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="c1"># Shuffle geometries for even load distribution across chunks</span>
        <span class="n">gmdf</span> <span class="o">=</span> <span class="n">gmdf</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">geom_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">gmdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">),</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">geom_chunks</span><span class="p">,</span> <span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">,</span> <span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">,</span> <span class="p">[</span><span class="n">dump</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>

        <span class="c1"># Parallel processing to generate cells</span>
        <span class="k">if</span> <span class="n">dump</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">n_cores</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">SpatialIndex</span><span class="o">.</span><span class="n">poly_cell</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">elapsed_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">n_cores</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">SpatialIndex</span><span class="o">.</span><span class="n">poly_cell</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">cells</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>  <span class="c1"># Flatten the list of cells</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">elapsed_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>

            <span class="c1"># Remove duplicates based on cell type</span>
            <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;geohash&quot;</span><span class="p">,</span> <span class="s2">&quot;s2&quot;</span><span class="p">}:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removing duplicate cells ... &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cells</span><span class="p">))</span>  <span class="c1"># Remove duplicate cells</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>

            <span class="n">cell_counts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>  <span class="c1"># Total unique cell count</span>

            <span class="c1"># Compact the cells if needed</span>
            <span class="k">if</span> <span class="n">compact</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compacting cells ... &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="n">CellUtils</span><span class="o">.</span><span class="n">compact_cells</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cell_counts</span></div>


<div class="viewcode-block" id="SpatialIndex.cell_point">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex.cell_point">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cell_point</span><span class="p">(</span><span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a list of cell IDs into their corresponding centroids.</span>

<span class="sd">        This function supports various cell ID types: &#39;geohash&#39;, &#39;h3&#39;, &#39;s2_int&#39; (integer-based S2 cells),</span>
<span class="sd">        and &#39;s2&#39; (token-based S2 cells). For each cell in the list, it returns the latitude and longitude</span>
<span class="sd">        of the cell&#39;s center.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cells : list of str or int</span>
<span class="sd">            List of cell identifiers. The format of each cell ID depends on the specified `cell_type`:</span>
<span class="sd">            - For &#39;geohash&#39;: `cells` should be a list of geohash strings.</span>
<span class="sd">            - For &#39;h3&#39;: `cells` should be a list of H3 cell ID strings.</span>
<span class="sd">            - For &#39;s2_int&#39;: `cells` should be a list of integer-based S2 cell IDs.</span>
<span class="sd">            - For &#39;s2&#39;: `cells` should be a list of S2 token strings.</span>
<span class="sd">        cell_type : str</span>
<span class="sd">            Type of the cell ID format. Should be one of the following:</span>
<span class="sd">            - &#39;geohash&#39;: Geohash encoding.</span>
<span class="sd">            - &#39;h3&#39;: H3 hexagonal grid encoding.</span>
<span class="sd">            - &#39;s2_int&#39;: Integer-based S2 cell ID.</span>
<span class="sd">            - &#39;s2&#39;: S2 token (string-based cell ID).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of tuple of float</span>
<span class="sd">            A list of tuples where each tuple contains the latitude and longitude (in degrees) of the</span>
<span class="sd">            center point for each cell ID.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `cell_type` is not one of &#39;geohash&#39;, &#39;h3&#39;, &#39;s2&#39;, or &#39;s2_int&#39;.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; cell_point([&quot;ezs42&quot;, &quot;u4pruydqqvj&quot;], cell_type=&quot;geohash&quot;)</span>
<span class="sd">        [(42.6, -5.6), (57.64911, 10.40744)]</span>

<span class="sd">        &gt;&gt;&gt; cell_point([&quot;8928308280fffff&quot;], cell_type=&quot;h3&quot;)</span>
<span class="sd">        [(37.775938728915946, -122.41795063018799)]</span>

<span class="sd">        &gt;&gt;&gt; cell_point([9744573459660040192], cell_type=&quot;s2_int&quot;)</span>
<span class="sd">        [(37.7749, -122.4194)]</span>

<span class="sd">        &gt;&gt;&gt; cell_point([&quot;89c25c&quot;], cell_type=&quot;s2&quot;)</span>
<span class="sd">        [(37.7749, -122.4194)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;geohash&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">pygeohash</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;h3&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">h3</span><span class="o">.</span><span class="n">cell_to_latlng</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;s2_int&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">s2</span><span class="o">.</span><span class="n">CellId</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">to_lat_lng</span><span class="p">()</span><span class="o">.</span><span class="n">lat</span><span class="p">()</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">CellId</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">to_lat_lng</span><span class="p">()</span><span class="o">.</span><span class="n">lng</span><span class="p">()</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;s2&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">CellId</span><span class="o">.</span><span class="n">from_token</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">to_lat_lng</span><span class="p">()</span><span class="o">.</span><span class="n">lat</span><span class="p">()</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">CellId</span><span class="o">.</span><span class="n">from_token</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">to_lat_lng</span><span class="p">()</span><span class="o">.</span><span class="n">lng</span><span class="p">()</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported cell type: </span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">. Choose &#39;geohash&#39;, &#39;s2&#39;, &#39;s2_int&#39;, or &#39;h3&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpatialIndex.cell_poly">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex.cell_poly">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cell_poly</span><span class="p">(</span><span class="n">cells</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a list of spatial cells to their corresponding geometries and resolution levels.</span>

<span class="sd">        The function takes a list of spatial cells (e.g., Geohash, H3, or S2) and converts each cell</span>
<span class="sd">        into a geometry object (Polygon) based on the specified cell type. It also calculates the resolution</span>
<span class="sd">        level for each cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cells : list</span>
<span class="sd">            A list of spatial cells represented as strings. Each cell corresponds to a spatial area</span>
<span class="sd">            in a specific grid system (e.g., Geohash, H3, or S2).</span>

<span class="sd">        cell_type : str</span>
<span class="sd">            The type of spatial cell system used. Accepted values are:</span>
<span class="sd">            - &quot;geohash&quot; : Geohash spatial indexing system.</span>
<span class="sd">            - &quot;h3&quot;      : H3 hexagonal spatial indexing system.</span>
<span class="sd">            - &quot;s2&quot;      : S2 spherical spatial indexing system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - `res` : list of int</span>
<span class="sd">                A list of resolution levels corresponding to each cell in the input.</span>
<span class="sd">            - `geoms` : list of shapely.geometry.Polygon</span>
<span class="sd">                A list of Polygon geometries representing the spatial boundaries of the input cells.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `cell_type` is not one of &quot;geohash&quot;, &quot;h3&quot;, or &quot;s2&quot;.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; cells = [&quot;ezs42&quot;, &quot;ezs43&quot;]  # Geohash cells</span>
<span class="sd">        &gt;&gt;&gt; cell_type = &quot;geohash&quot;</span>
<span class="sd">        &gt;&gt;&gt; res, geoms = cell_poly(cells, cell_type)</span>
<span class="sd">        &gt;&gt;&gt; print(res)</span>
<span class="sd">        [5, 5]  # Resolution levels of the input cells</span>
<span class="sd">        &gt;&gt;&gt; print(geoms)</span>
<span class="sd">        [&lt;shapely.geometry.polygon.Polygon object at 0x...&gt;, &lt;shapely.geometry.polygon.Polygon object at 0x...&gt;]</span>
<span class="sd">        # Polygon geometries representing the spatial boundaries of the cells</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The function supports three spatial indexing systems:</span>
<span class="sd">        - Geohash: Uses rectangular bounding boxes to represent cells.</span>
<span class="sd">        - H3: Uses hexagonal grid cells.</span>
<span class="sd">        - S2: Uses spherical grid cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for valid cell_type</span>
        <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;geohash&quot;</span><span class="p">,</span> <span class="s2">&quot;h3&quot;</span><span class="p">,</span> <span class="s2">&quot;s2&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid cell_type &#39;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&#39;. Accepted values are: &#39;geohash&#39;, &#39;h3&#39;, &#39;s2&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Determine resolution level based on cell type</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;geohash&quot;</span>
            <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;h3&quot;</span>
            <span class="k">else</span> <span class="n">s2</span><span class="o">.</span><span class="n">CellId</span><span class="o">.</span><span class="n">from_token</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">level</span><span class="p">()</span>  <span class="c1"># cell = token</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span>
        <span class="p">]</span>

        <span class="c1"># Create geometry objects based on cell type</span>
        <span class="n">geoms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">geohash_to_polygon</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;geohash&quot;</span>
            <span class="k">else</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">s2_to_geo_boundary</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">geo_json_conformant</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;s2&quot;</span>
            <span class="c1"># Shapely expects (lng, lat) format, so we reverse the coordinates returned by cell_to_boundary</span>
            <span class="k">else</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">lng</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lng</span> <span class="ow">in</span> <span class="n">h3</span><span class="o">.</span><span class="n">cell_to_boundary</span><span class="p">(</span><span class="n">cell</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">geoms</span></div>


<div class="viewcode-block" id="SpatialIndex.pcell_point">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex.pcell_point">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pcell_point</span><span class="p">(</span><span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a list of cell IDs into their corresponding latitude and longitude points in parallel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cells : list of str or int</span>
<span class="sd">            List of cell identifiers.</span>
<span class="sd">        cell_type : str</span>
<span class="sd">            Type of the cell ID format.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of tuple of float</span>
<span class="sd">            List of tuples containing the latitude and longitude (in degrees) of each cell ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_cores</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>

        <span class="c1"># Prepare arguments for parallel processing</span>
        <span class="n">cell_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cell_chunks</span><span class="p">,</span> <span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>

        <span class="c1"># Parallelize the conversion using Pool.starmap</span>
        <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">n_cores</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">SpatialIndex</span><span class="o">.</span><span class="n">cell_point</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">points</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>  <span class="c1"># Flatten the list of cells</span>

        <span class="k">return</span> <span class="n">points</span></div>


<div class="viewcode-block" id="SpatialIndex.pcell_poly">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialIndex.pcell_poly">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pcell_poly</span><span class="p">(</span><span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parallelized version of `cell_poly`, converting a list of spatial cells to geometries and resolution levels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cells : list of str or int</span>
<span class="sd">            List of spatial cells in a specific grid system.</span>

<span class="sd">        cell_type : str</span>
<span class="sd">            Type of spatial cell system (&quot;geohash&quot;, &quot;h3&quot;, or &quot;s2&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - `res` : list of int</span>
<span class="sd">                Resolution levels for each cell in the input.</span>
<span class="sd">            - `geoms` : list of shapely.geometry.Polygon</span>
<span class="sd">                Polygon geometries representing the boundaries of input cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_cores</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>

        <span class="n">cell_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>
        <span class="c1"># Convert each numpy array to a list which converts numpy.str_ to str</span>
        <span class="n">cell_chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">cell_chunks</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cell_chunks</span><span class="p">,</span> <span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">n_cores</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">SpatialIndex</span><span class="o">.</span><span class="n">cell_poly</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="c1"># Unpack `res` and `geoms` from the result tuples</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">geoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">geoms</span></div>
</div>



<div class="viewcode-block" id="SpatialOps">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialOps">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SpatialOps</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility class for performing advanced spatial operations on GeoDataFrames and geometries.</span>

<span class="sd">    This class provides methods for handling 3D geometries, converting LineStrings to Points,</span>
<span class="sd">    performing spatial intersections, and executing parallelized spatial overlay operations.</span>
<span class="sd">    It is designed to work with GeoPandas GeoDataFrames and Shapely geometries.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    flatten_3d(geom: gpd.GeoSeries) -&gt; List[Union[Polygon, MultiPolygon]]</span>
<span class="sd">        Converts 3D geometries in a GeoSeries to 2D geometries by removing the z-coordinate.</span>

<span class="sd">    line_to_points(row: gpd.GeoSeries) -&gt; gpd.GeoDataFrame</span>
<span class="sd">        Splits a LineString geometry into individual Point geometries while preserving attributes.</span>

<span class="sd">    intersection(gdf1: gpd.GeoDataFrame, gdf2: gpd.GeoDataFrame, poly_id: Optional[str] = None) -&gt; gpd.GeoDataFrame</span>
<span class="sd">        Performs a spatial intersection between two GeoDataFrames and returns the intersecting subset.</span>

<span class="sd">    quick_intersection(gdf1: gpd.GeoDataFrame, gdf2: gpd.GeoDataFrame, poly_id: Optional[str] = None) -&gt; gpd.GeoDataFrame</span>
<span class="sd">        Performs an optimized spatial intersection using bounding box filtering and spatial indexing.</span>

<span class="sd">    poverlay(gdf1: gpd.GeoDataFrame, gdf2: gpd.GeoDataFrame, how: str = &quot;intersection&quot;, keep_geom_type: bool = False) -&gt; gpd.GeoDataFrame</span>
<span class="sd">        Executes a parallelized spatial overlay operation between two GeoDataFrames.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The class relies on GeoPandas and Shapely for spatial operations and multiprocessing for parallelization.</span>
<span class="sd">    - Ensure that input GeoDataFrames have the same coordinate reference system (CRS) for accurate results.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; spatial_ops = SpatialOps()</span>

<span class="sd">    &gt;&gt;&gt; # Example for flatten_3d</span>
<span class="sd">    &gt;&gt;&gt; gdf_2d = spatial_ops.flatten_3d(gdf.geometry)</span>
<span class="sd">    &gt;&gt;&gt; print(gdf_2d)</span>

<span class="sd">    &gt;&gt;&gt; # Example for line_to_points</span>
<span class="sd">    &gt;&gt;&gt; point_gdf = spatial_ops.line_to_points(line_gdf.iloc[0])</span>
<span class="sd">    &gt;&gt;&gt; print(point_gdf)</span>

<span class="sd">    &gt;&gt;&gt; # Example for intersection</span>
<span class="sd">    &gt;&gt;&gt; result_gdf = spatial_ops.intersection(gdf1, gdf2, poly_id=&quot;region_id&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(result_gdf)</span>

<span class="sd">    &gt;&gt;&gt; # Example for quick_intersection</span>
<span class="sd">    &gt;&gt;&gt; result_gdf = spatial_ops.quick_intersection(gdf1, gdf2, poly_id=&quot;region_id&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(result_gdf)</span>

<span class="sd">    &gt;&gt;&gt; # Example for poverlay</span>
<span class="sd">    &gt;&gt;&gt; result_gdf = spatial_ops.poverlay(gdf1, gdf2, how=&quot;intersection&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(result_gdf)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpatialOps.intersection">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialOps.intersection">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersection</span><span class="p">(</span><span class="n">gdf1</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">poly_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a spatial intersection between two GeoDataFrames and return the intersecting subset of the first GeoDataFrame.</span>

<span class="sd">        This function identifies geometries in `gdf1` that intersect with any geometries in `gdf2`. It adds a new column, `counts`,</span>
<span class="sd">        to `gdf2` representing the number of intersecting geometries for each feature in `gdf2`. If a `poly_id` column is specified,</span>
<span class="sd">        it also adds the geometry ID from `gdf2` to the intersected subset of `gdf1`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf1 : geopandas.GeoDataFrame</span>
<span class="sd">            The first GeoDataFrame whose geometries are tested for intersection with `gdf2`.</span>
<span class="sd">        gdf2 : geopandas.GeoDataFrame</span>
<span class="sd">            The second GeoDataFrame containing geometries to intersect with `gdf1`.</span>
<span class="sd">        poly_id : str, optional</span>
<span class="sd">            The column name in `gdf2` containing unique geometry identifiers. If provided, the intersected subset of `gdf1`</span>
<span class="sd">            will include a new column `geom_id` indicating the geometry ID from `gdf2` that each feature intersects with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geopandas.GeoDataFrame</span>
<span class="sd">            A new GeoDataFrame containing only the intersecting geometries from `gdf1` with respect to `gdf2`.</span>
<span class="sd">            If `poly_id` is provided, the intersected GeoDataFrame will also include a `geom_id` column.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gdf1 = geopandas.read_file(&quot;data1.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; gdf2 = geopandas.read_file(&quot;data2.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; result_gdf = intersection(gdf1, gdf2, poly_id=&quot;region_id&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The function modifies `gdf2` in place by adding a `counts` column, which reflects the number of geometries</span>
<span class="sd">        in `gdf1` that intersect with each geometry in `gdf2`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">int_gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>  <span class="c1"># Initialize an empty DataFrame to store intersecting geometries from gdf1</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store counts of intersecting geometries for each feature in gdf2</span>

        <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">gdf2</span><span class="o">.</span><span class="n">geometry</span><span class="p">:</span>
            <span class="c1"># Filter `gdf1` to retain only geometries that intersect with the current geometry in `gdf2`</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf1</span><span class="p">[</span><span class="n">gdf1</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geom</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">poly_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If `poly_id` is provided, retrieve the geometry ID from `gdf2` and assign it to `geom_id` column in `gdf`</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">gdf2</span><span class="p">[</span><span class="n">gdf2</span><span class="o">.</span><span class="n">geometry</span> <span class="o">==</span> <span class="n">geom</span><span class="p">][</span><span class="n">poly_id</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gid</span>

            <span class="c1"># Concatenate the intersecting geometries to the final DataFrame</span>
            <span class="n">int_gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">int_gdf</span><span class="p">,</span> <span class="n">gdf</span><span class="p">])</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">))</span>  <span class="c1"># Store the number of intersecting geometries for the current feature in gdf2</span>

        <span class="n">gdf2</span><span class="p">[</span><span class="s2">&quot;counts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>  <span class="c1"># Add the counts of intersecting geometries as a new column in gdf2</span>
        <span class="k">return</span> <span class="n">int_gdf</span>  <span class="c1"># Return the intersected subset of gdf1</span></div>


<div class="viewcode-block" id="SpatialOps.quick_intersection">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialOps.quick_intersection">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">quick_intersection</span><span class="p">(</span><span class="n">gdf1</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">poly_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a quick spatial intersection between two GeoDataFrames using bounding box optimization.</span>

<span class="sd">        This function identifies geometries in `gdf1` that intersect with any geometries in `gdf2`. It uses</span>
<span class="sd">        a spatial index to quickly filter `gdf1` geometries that are likely to intersect with the bounding</span>
<span class="sd">        box of each geometry in `gdf2`. It then performs a precise intersection check on this subset, improving</span>
<span class="sd">        the performance of the intersection operation.</span>

<span class="sd">        If a `poly_id` column is provided, the function adds a new `geom_id` column to the resulting intersected</span>
<span class="sd">        GeoDataFrame, storing the geometry ID from `gdf2` that each feature in `gdf1` intersects with. It also</span>
<span class="sd">        modifies `gdf2` by adding a `counts` column to indicate the number of intersecting geometries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf1 : geopandas.GeoDataFrame</span>
<span class="sd">            The first GeoDataFrame whose geometries are tested for intersection with `gdf2`.</span>
<span class="sd">        gdf2 : geopandas.GeoDataFrame</span>
<span class="sd">            The second GeoDataFrame containing geometries to intersect with `gdf1`.</span>
<span class="sd">        poly_id : str, optional</span>
<span class="sd">            The column name in `gdf2` containing unique geometry identifiers. If provided, the intersected subset of `gdf1`</span>
<span class="sd">            will include a new column `geom_id` indicating the geometry ID from `gdf2` that each feature intersects with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geopandas.GeoDataFrame</span>
<span class="sd">            A new GeoDataFrame containing only the intersecting geometries from `gdf1` with respect to `gdf2`.</span>
<span class="sd">            If `poly_id` is provided, the intersected GeoDataFrame will also include a `geom_id` column.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gdf1 = geopandas.read_file(&quot;data1.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; gdf2 = geopandas.read_file(&quot;data2.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; result_gdf = quick_intersection(gdf1, gdf2, poly_id=&quot;region_id&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This function modifies `gdf2` in place by adding a `counts` column, which reflects the number of geometries</span>
<span class="sd">          in `gdf1` that intersect with each geometry in `gdf2`.</span>
<span class="sd">        - It leverages spatial indexing using the `sindex` attribute of `gdf1` to quickly identify candidates for</span>
<span class="sd">          intersection, which significantly improves performance for large datasets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">int_gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>  <span class="c1"># Initialize an empty DataFrame to store intersecting geometries from gdf1</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store counts of intersecting geometries for each feature in gdf2</span>

        <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">gdf2</span><span class="o">.</span><span class="n">geometry</span><span class="p">:</span>
            <span class="c1"># Get the indices of geometries in `gdf1` that are likely to intersect the bounding box of `geom` in `gdf2`</span>
            <span class="n">pos_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gdf1</span><span class="o">.</span><span class="n">sindex</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>

            <span class="c1"># Select the subset of `gdf1` based on these indices</span>
            <span class="n">pos_gdf</span> <span class="o">=</span> <span class="n">gdf1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">pos_idx</span><span class="p">]</span>

            <span class="c1"># Filter the subset to retain only geometries that precisely intersect with `geom`</span>
            <span class="n">pre_gdf</span> <span class="o">=</span> <span class="n">pos_gdf</span><span class="p">[</span><span class="n">pos_gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geom</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">poly_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_gdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If `poly_id` is provided, assign the geometry ID from `gdf2` to the `geom_id` column in `pre_gdf`</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">gdf2</span><span class="p">[</span><span class="n">gdf2</span><span class="o">.</span><span class="n">geometry</span> <span class="o">==</span> <span class="n">geom</span><span class="p">][</span><span class="n">poly_id</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pre_gdf</span><span class="p">[</span><span class="s2">&quot;geom_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gid</span>

            <span class="c1"># Concatenate the precise intersecting geometries to the final intersected DataFrame</span>
            <span class="n">int_gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">int_gdf</span><span class="p">,</span> <span class="n">pre_gdf</span><span class="p">])</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pre_gdf</span><span class="p">))</span>  <span class="c1"># Store the number of intersecting geometries for the current feature in gdf2</span>

        <span class="n">gdf2</span><span class="p">[</span><span class="s2">&quot;counts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>  <span class="c1"># Add the counts of intersecting geometries as a new column in gdf2</span>
        <span class="k">return</span> <span class="n">int_gdf</span>  <span class="c1"># Return the intersected subset of gdf1</span></div>


<div class="viewcode-block" id="SpatialOps.poverlay">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialOps.poverlay">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">poverlay</span><span class="p">(</span>
        <span class="n">gdf1</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;intersection&quot;</span><span class="p">,</span> <span class="n">keep_geom_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a spatial overlay operation between two GeoDataFrames in parallel using multiple CPU cores.</span>

<span class="sd">        This function divides the first GeoDataFrame into chunks according to the number of available CPU cores</span>
<span class="sd">        and applies the specified overlay operation (e.g., intersection, union, difference) in parallel on each chunk</span>
<span class="sd">        with respect to the second GeoDataFrame. The results are then concatenated and returned as a single GeoDataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf1 : gpd.GeoDataFrame</span>
<span class="sd">            The first GeoDataFrame to be used in the spatial overlay operation.</span>
<span class="sd">        gdf2 : gpd.GeoDataFrame</span>
<span class="sd">            The second GeoDataFrame to be used in the spatial overlay operation.</span>
<span class="sd">        how : str, optional</span>
<span class="sd">            The type of overlay operation to perform. Options include &quot;intersection&quot;, &quot;union&quot;, &quot;difference&quot;,</span>
<span class="sd">            &quot;symmetric_difference&quot;, and &quot;identity&quot;. Defaults to &quot;intersection&quot;.</span>
<span class="sd">        keep_geom_type : bool, optional</span>
<span class="sd">            Whether to retain the original geometry type (e.g., Polygon, LineString) in the resulting overlay.</span>
<span class="sd">            If set to True, only features of the same geometry type are retained. Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gpd.GeoDataFrame</span>
<span class="sd">            A new GeoDataFrame resulting from the spatial overlay operation, with the same coordinate reference system</span>
<span class="sd">            (CRS) as the first input GeoDataFrame (`gdf1`).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gdf1 = gpd.GeoDataFrame({&quot;geometry&quot;: [Polygon([(0, 0), (2, 0), (2, 2), (0, 2)])]})</span>
<span class="sd">        &gt;&gt;&gt; gdf2 = gpd.GeoDataFrame({&quot;geometry&quot;: [Polygon([(1, 1), (3, 1), (3, 3), (1, 3)])]})</span>
<span class="sd">        &gt;&gt;&gt; result_gdf = poverlay(gdf1, gdf2, how=&quot;intersection&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(result_gdf)</span>
<span class="sd">                                                     geometry</span>
<span class="sd">        0  POLYGON ((2.00000 1.00000, 2.00000 2.00000, 1....</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The spatial overlay operation is performed using the `geopandas.overlay` function. The parallelization is achieved</span>
<span class="sd">          using the `multiprocessing` library to divide and distribute the overlay operations across multiple CPU cores.</span>
<span class="sd">        - Ensure that both GeoDataFrames (`gdf1` and `gdf2`) have the same coordinate reference system (CRS) before applying</span>
<span class="sd">          the overlay operation to avoid unexpected results.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `how` parameter is not one of the supported overlay operation types: &quot;intersection&quot;, &quot;union&quot;,</span>
<span class="sd">            &quot;difference&quot;, &quot;symmetric_difference&quot;, or &quot;identity&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the number of CPU cores available for parallel processing</span>
        <span class="n">n_cores</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>

        <span class="c1"># Split the first GeoDataFrame into chunks for parallel processing</span>
        <span class="n">gdf1_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">n_cores</span><span class="p">)</span>

        <span class="c1"># Create a list of the second GeoDataFrame repeated for each chunk</span>
        <span class="n">gdf2_chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">gdf2</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_cores</span>

        <span class="c1"># Prepare inputs for the parallel processing pool</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf1_chunks</span><span class="p">,</span> <span class="n">gdf2_chunks</span><span class="p">,</span> <span class="p">[</span><span class="n">how</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">,</span> <span class="p">[</span><span class="n">keep_geom_type</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_cores</span><span class="p">)</span>

        <span class="c1"># Create a multiprocessing pool and apply the overlay function in parallel on each chunk</span>
        <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">n_cores</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">,</span> <span class="n">inputs</span><span class="p">),</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span></div>


<div class="viewcode-block" id="SpatialOps.haversine">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialOps.haversine">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">haversine</span><span class="p">(</span><span class="n">lat1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lon1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lat2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lon2</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the great-circle distance between two points on the Earth&#39;s surface.</span>

<span class="sd">        The haversine formula determines the shortest distance over the Earth&#39;s surface</span>
<span class="sd">        between two points given their latitudes and longitudes. The result is the</span>
<span class="sd">        distance in meters, based on a mean Earth radius.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lat1 : float</span>
<span class="sd">            Latitude of the first point in decimal degrees.</span>
<span class="sd">        lon1 : float</span>
<span class="sd">            Longitude of the first point in decimal degrees.</span>
<span class="sd">        lat2 : float</span>
<span class="sd">            Latitude of the second point in decimal degrees.</span>
<span class="sd">        lon2 : float</span>
<span class="sd">            Longitude of the second point in decimal degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The great-circle distance between the two points in meters.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Haversine_formula</span>
<span class="sd">        .. [2] https://en.wikipedia.org/wiki/Longitude</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; haversine(52.2296756, 21.0122287, 41.8919300, 12.5113300)</span>
<span class="sd">        1319743.483</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The mean Earth radius is taken as 6,371,008.8 meters.</span>
<span class="sd">        a = 6378137.0        # Equatorial radius</span>
<span class="sd">        b = 6356752.3142     # Polar radius</span>
<span class="sd">        R = (2*a + b)/3      # Mean radius = 6371008.7714</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mf">6371008.8</span>  <span class="c1"># Mean Earth radius in meters</span>
        <span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">dlon</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">lat1</span><span class="p">),</span> <span class="n">radians</span><span class="p">(</span><span class="n">lat2</span><span class="p">),</span> <span class="n">radians</span><span class="p">(</span><span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span><span class="p">)</span>
        <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">dlat</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">dlon</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">atan2</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span>  <span class="c1"># Angular distance in radians</span>
        <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">c</span>  <span class="c1"># Distance in meters</span></div>


<div class="viewcode-block" id="SpatialOps.vincenty">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialOps.vincenty">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vincenty</span><span class="p">(</span><span class="n">lat1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lon1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lat2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lon2</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the geodesic distance between two points on the Earth&#39;s surface</span>
<span class="sd">        using the Vincenty formula, which accounts for the Earth&#39;s ellipsoidal shape.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - lat1, lon1: Latitude and longitude of the first point (in degrees).</span>
<span class="sd">        - lat2, lon2: Latitude and longitude of the second point (in degrees).</span>

<span class="sd">        Returns:</span>
<span class="sd">        - Distance between the two points in meters.</span>

<span class="sd">        Notes:</span>
<span class="sd">        - This implementation may encounter numerical issues, such as divide-by-zero errors,</span>
<span class="sd">          in edge cases where the points are on opposite sides of the Earth or on the same meridian</span>
<span class="sd">          e.g., from (0,0) to (0,90).However, for points (0,0) to (0.001,90), the distance calculation</span>
<span class="sd">          is accurate within a small error margin (about 9.3e-06 meters).</span>

<span class="sd">        - The error in the above approach can be significant for very small distances,</span>
<span class="sd">          such as between (0,0) and (0,0.001).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Constants for WGS-84 ellipsoid</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">6378137.0</span>  <span class="c1"># Equatorial radius in meters</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">298.257223563</span>  <span class="c1"># Flattening</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span>  <span class="c1"># Polar radius</span>

        <span class="c1"># Convert degrees to radians</span>
        <span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">,</span> <span class="p">[</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span><span class="p">])</span>

        <span class="c1"># Differences in longitude</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>

        <span class="c1"># Iterative Vincenty formula</span>
        <span class="n">u1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">lat1</span><span class="p">))</span>
        <span class="n">u2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">lat2</span><span class="p">))</span>
        <span class="n">sin_u1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
        <span class="n">cos_u1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
        <span class="n">sin_u2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">u2</span><span class="p">)</span>
        <span class="n">cos_u2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">u2</span><span class="p">)</span>

        <span class="n">lambda_</span> <span class="o">=</span> <span class="n">ll</span>
        <span class="n">lambda_prev</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">1e-12</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
            <span class="n">sin_lambda</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lambda_</span><span class="p">)</span>
            <span class="n">cos_lambda</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lambda_</span><span class="p">)</span>
            <span class="n">sin_sigma</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">cos_u2</span> <span class="o">*</span> <span class="n">sin_lambda</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">cos_u1</span> <span class="o">*</span> <span class="n">sin_u2</span> <span class="o">-</span> <span class="n">sin_u1</span> <span class="o">*</span> <span class="n">cos_u2</span> <span class="o">*</span> <span class="n">cos_lambda</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">cos_sigma</span> <span class="o">=</span> <span class="n">sin_u1</span> <span class="o">*</span> <span class="n">sin_u2</span> <span class="o">+</span> <span class="n">cos_u1</span> <span class="o">*</span> <span class="n">cos_u2</span> <span class="o">*</span> <span class="n">cos_lambda</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">sin_sigma</span><span class="p">,</span> <span class="n">cos_sigma</span><span class="p">)</span>
            <span class="n">sin_alpha</span> <span class="o">=</span> <span class="n">cos_u1</span> <span class="o">*</span> <span class="n">cos_u2</span> <span class="o">*</span> <span class="n">sin_lambda</span> <span class="o">/</span> <span class="n">sin_sigma</span>
            <span class="n">cos2_alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sin_alpha</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">cos2_sigma_m</span> <span class="o">=</span> <span class="n">cos_sigma</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sin_u1</span> <span class="o">*</span> <span class="n">sin_u2</span> <span class="o">/</span> <span class="n">cos2_alpha</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">f</span> <span class="o">/</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">cos2_alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">cos2_alpha</span><span class="p">))</span>
            <span class="n">lambda_prev</span> <span class="o">=</span> <span class="n">lambda_</span>
            <span class="n">lambda_</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cc</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">sin_alpha</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">sigma</span> <span class="o">+</span> <span class="n">cc</span> <span class="o">*</span> <span class="n">sin_sigma</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos2_sigma_m</span> <span class="o">+</span> <span class="n">cc</span> <span class="o">*</span> <span class="n">cos_sigma</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos2_sigma_m</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lambda_</span> <span class="o">-</span> <span class="n">lambda_prev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vincenty formula did not converge&quot;</span><span class="p">)</span>

        <span class="n">u2</span> <span class="o">=</span> <span class="n">cos2_alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">aa</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">u2</span> <span class="o">/</span> <span class="mi">16384</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">u2</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">768</span> <span class="o">+</span> <span class="n">u2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">320</span> <span class="o">-</span> <span class="mi">175</span> <span class="o">*</span> <span class="n">u2</span><span class="p">)))</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">u2</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">*</span> <span class="p">(</span><span class="mi">256</span> <span class="o">+</span> <span class="n">u2</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">128</span> <span class="o">+</span> <span class="n">u2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">74</span> <span class="o">-</span> <span class="mi">47</span> <span class="o">*</span> <span class="n">u2</span><span class="p">)))</span>
        <span class="n">delta_sigma</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">bb</span>
            <span class="o">*</span> <span class="n">sin_sigma</span>
            <span class="o">*</span> <span class="p">(</span>
                <span class="n">cos2_sigma_m</span>
                <span class="o">+</span> <span class="n">bb</span>
                <span class="o">/</span> <span class="mi">4</span>
                <span class="o">*</span> <span class="p">(</span>
                    <span class="n">cos_sigma</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos2_sigma_m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">bb</span> <span class="o">/</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">cos2_sigma_m</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sin_sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">cos2_sigma_m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">aa</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">-</span> <span class="n">delta_sigma</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="SpatialOps.geocoding_google">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialOps.geocoding_google">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geocoding_google</span><span class="p">(</span><span class="n">address_or_zipcode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">api_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns geographic coordinates (latitude and longitude) for a given address or zip code using the Google Geocoding API.</span>

<span class="sd">        This function utilizes the Google Geocoding API to convert a given address or zip code into geographic coordinates.</span>
<span class="sd">        The function returns the latitude and longitude as a pandas Series. If the request is unsuccessful or the address</span>
<span class="sd">        is not found, the function returns a Series with `(None, None)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        address_or_zipcode : str</span>
<span class="sd">            A text-based address or zip code that needs to be geocoded.</span>
<span class="sd">        api_key : str</span>
<span class="sd">            A valid Google Maps API key required to access the Google Geocoding service.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Series</span>
<span class="sd">            A pandas Series containing the latitude and longitude as floats. If the request fails or the address is not found,</span>
<span class="sd">            returns a Series with `(None, None)`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df[[&quot;lat&quot;, &quot;lon&quot;]] = df.apply(lambda row: geocoding_google(row.address, &quot;your_api_key&quot;), axis=1)</span>
<span class="sd">        &gt;&gt;&gt; result = geocoding_google(&quot;1600 Amphitheatre Parkway, Mountain View, CA&quot;, &quot;your_api_key&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        lat    37.4224764</span>
<span class="sd">        lon   -122.0842499</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Make sure to enable the Google Geocoding API in your Google Cloud Console and provide a valid API key.</span>
<span class="sd">        - The API might return ambiguous results if the input address is incomplete or vague.</span>
<span class="sd">        - Consider handling `None` values in the returned Series if the API fails to find the address or the request limit is exceeded.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            If there is an error in the API request or response parsing, an exception is raised with an error message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">base_url</span> <span class="o">=</span> <span class="s2">&quot;https://maps.googleapis.com/maps/api/geocode/json&quot;</span>
        <span class="n">endpoint</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_url</span><span class="si">}</span><span class="s2">?address=</span><span class="si">{</span><span class="n">address_or_zipcode</span><span class="si">}</span><span class="s2">&amp;key=</span><span class="si">{</span><span class="n">api_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">endpoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">299</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This try block incase any of our inputs are invalid. This is done instead</span>
<span class="sd">            of actually writing out handlers for all kinds of responses.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s2">&quot;results&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">][</span><span class="s2">&quot;location&quot;</span><span class="p">][</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">][</span><span class="s2">&quot;location&quot;</span><span class="p">][</span><span class="s2">&quot;lng&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># Handle any errors that may occur</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">])</span></div>


<div class="viewcode-block" id="SpatialOps.reverse_geocoding_google">
<a class="viewcode-back" href="../../geoparse.html#geoparse.geoparse.SpatialOps.reverse_geocoding_google">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reverse_geocoding_google</span><span class="p">(</span><span class="n">lat</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lon</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">api_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the postal code for a given geographic coordinate (latitude, longitude) using the Google Geocoding API.</span>

<span class="sd">        This function makes a reverse geocoding request to the Google Geocoding API to obtain the postal code associated</span>
<span class="sd">        with the provided latitude and longitude. If the postal code is found, it is returned as a string. If not,</span>
<span class="sd">        `None` is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lat : float</span>
<span class="sd">            The latitude of the location to reverse geocode.</span>
<span class="sd">        lon : float</span>
<span class="sd">            The longitude of the location to reverse geocode.</span>
<span class="sd">        api_key : str</span>
<span class="sd">            A valid Google Maps API key for accessing the geocoding service.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The postal code corresponding to the input geographic coordinates, if found. Returns `None` if no postal code</span>
<span class="sd">            is found or if the request fails.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; reverse_geocoding_google(37.4224764, -122.0842499, &quot;your_api_key&quot;)</span>
<span class="sd">        &#39;94043&#39;</span>

<span class="sd">        &gt;&gt;&gt; df[&quot;postcode&quot;] = df.apply(lambda row: reverse_geocoding_google(row.lat, row.lon, &quot;your_api_key&quot;), axis=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0001</span> <span class="k">else</span> <span class="n">lat</span>  <span class="c1"># Prevent invalid &#39;latlng&#39; error for very small values.</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0001</span> <span class="k">else</span> <span class="n">lon</span>

        <span class="c1"># Make the reverse geocoding request</span>
        <span class="n">url</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;https://maps.googleapis.com/maps/api/geocode/json?latlng=</span><span class="si">{</span><span class="n">lat</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">lon</span><span class="si">}</span><span class="s2">&amp;key=</span><span class="si">{</span><span class="n">api_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

        <span class="c1"># Parse the response to extract the postal code</span>
        <span class="k">if</span> <span class="s2">&quot;results&quot;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;address_components&quot;</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="k">if</span> <span class="s2">&quot;postal_code&quot;</span> <span class="ow">in</span> <span class="n">component</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;types&quot;</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">[</span><span class="s2">&quot;types&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">component</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;long_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</div>



<span class="n">plp</span> <span class="o">=</span> <span class="n">Karta</span><span class="o">.</span><span class="n">plp</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Abbas Kiasari.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>